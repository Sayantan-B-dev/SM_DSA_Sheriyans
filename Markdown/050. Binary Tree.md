# Same Tree (LeetCode 100)

## Overview

This code checks whether two binary trees are **structurally identical** and have the **same node values**.

* **Definition of "Same Tree":**

  1. Both trees are empty → they are the same.
  2. Both trees have the same root value.
  3. Left subtrees are the same, and right subtrees are the same.

---

## Approach

1. **Recursive Comparison**

   * Base case 1: If both nodes are `null`, return `true`.
   * Base case 2: If only one node is `null`, return `false`.
   * If node values differ, return `false`.
   * Recursively compare left children and right children.
   * Both left and right comparisons must be `true` for trees to be identical.

2. **Alternative Approaches**

   * **DFS Iterative using stack:** Push pairs of nodes and compare iteratively.
   * **BFS using queue:** Compare nodes level by level.

---

## Algorithm

1. If both `p` and `q` are `null`, return `true`.
2. If either `p` or `q` is `null`, return `false`.
3. If `p.val != q.val`, return `false`.
4. Recursively check left subtrees: `isSameTree(p.left, q.left)`
5. Recursively check right subtrees: `isSameTree(p.right, q.right)`
6. Return `true` only if **both left and right comparisons** are `true`.

---

## Pseudocode

```
FUNCTION isSameTree(p, q):
    // Both nodes are null → identical
    IF p == NULL AND q == NULL THEN
        RETURN true
    
    // One node is null → not identical
    IF p == NULL OR q == NULL THEN
        RETURN false
    
    // Node values differ → not identical
    IF p.val != q.val THEN
        RETURN false
    
    // Recursively check left and right subtrees
    leftSame = isSameTree(p.left, q.left)
    rightSame = isSameTree(p.right, q.right)
    
    // Both left and right must be true
    RETURN leftSame AND rightSame
```

**Commentary:**

* Recursion checks **structural and value equality** simultaneously.
* Short-circuits occur when `false` is encountered, improving efficiency.

---

## Flowchart

```
          [Start: nodes p and q]
                  |
       [Are both p and q null?]---Yes--->[Return true]
                  |
                  No
                  |
       [Is either p or q null?]---Yes--->[Return false]
                  |
                  No
                  |
       [Do p.val and q.val differ?]---Yes--->[Return false]
                  |
                  No
                  |
       [Compare left subtrees recursively]
                  |
       [Compare right subtrees recursively]
                  |
          [Return left AND right results]
```

---

## Dry Run Example

Input trees:

Tree `p`:

```
    1
   / \
  2   3
```

Tree `q`:

```
    1
   / \
  2   3
```

**Step-by-step:**

1. Compare roots: `1 == 1` → continue
2. Compare left children: `2 == 2` → continue

   * Left and right children of 2 are `null` → return `true`
3. Compare right children: `3 == 3` → continue

   * Left and right children of 3 are `null` → return `true`
4. Both left and right subtrees are identical → return `true`

**Output:** `true`

If a node value differed (e.g., `q.right = 4`), comparison at that node would return `false`, short-circuiting the recursion.

---

# Symmetric Tree (LeetCode 101)

## Overview

This code checks whether a binary tree is **symmetric** around its center.

* **Definition of Symmetry:**
  A tree is symmetric if the left subtree is a **mirror image** of the right subtree.

---

## Approach

1. **Recursive Mirror Comparison**

   * Base case 1: If both nodes are `null`, they are symmetric → return `true`.
   * Base case 2: If only one node is `null`, not symmetric → return `false`.
   * If node values differ, return `false`.
   * Recursively compare:

     * Left child of left subtree with right child of right subtree
     * Right child of left subtree with left child of right subtree
   * Both recursive comparisons must be `true` for symmetry.

2. **Alternative Approaches**

   * **DFS iterative with stack:** Push pairs of nodes in mirrored positions and compare iteratively.
   * **BFS with queue:** Enqueue mirrored node pairs level by level.

---

## Algorithm

1. If `root` is `null`, return `true`.
2. Define a helper function `dfs(L, R)` to check mirrored nodes.
3. In `dfs(L, R)`:

   * If `L` and `R` are both `null`, return `true`.
   * If either `L` or `R` is `null`, return `false`.
   * If `L.val != R.val`, return `false`.
   * Recursively check mirrored children:

     * `dfs(L.left, R.right)`
     * `dfs(L.right, R.left)`
   * Return `true` only if both are `true`.
4. Call `dfs(root.left, root.right)` and return its result.

---

## Pseudocode

```
FUNCTION isSymmetric(root):
    // Empty tree is symmetric
    IF root == NULL THEN
        RETURN true
    
    FUNCTION dfs(L, R):
        // Both nodes null → symmetric
        IF L == NULL AND R == NULL THEN
            RETURN true
        
        // Only one node null → not symmetric
        IF L == NULL OR R == NULL THEN
            RETURN false
        
        // Node values differ → not symmetric
        IF L.val != R.val THEN
            RETURN false
        
        // Recursively compare mirrored children
        leftCheck = dfs(L.left, R.right)
        rightCheck = dfs(L.right, R.left)
        
        RETURN leftCheck AND rightCheck
    
    RETURN dfs(root.left, root.right)
```

**Commentary:**

* The key idea is **mirrored recursion**: compare nodes at mirrored positions.
* Symmetry requires **both left-right and right-left comparisons** to hold.

---

## Flowchart

```
          [Start: root node]
                  |
       [Is root null?]---Yes--->[Return true]
                  |
                  No
                  |
         [Call dfs(root.left, root.right)]
                  |
       [In dfs(L,R): Are both null?]---Yes--->[Return true]
                  |
       [Is either null?]---Yes--->[Return false]
                  |
       [Do L.val and R.val differ?]---Yes--->[Return false]
                  |
       [Compare L.left with R.right recursively]
                  |
       [Compare L.right with R.left recursively]
                  |
          [Return left AND right results]
```

---

## Dry Run Example

Input tree:

```
       1
     /   \
    2     2
   / \   / \
  3   4 4   3
```

**Step-by-step:**

1. `isSymmetric(root)` → call `dfs(2, 2)`
2. Compare `L.val = 2` and `R.val = 2` → equal
3. Compare mirrored children:

   * `dfs(3, 3)` → `true` (both leaves)
   * `dfs(4, 4)` → `true` (both leaves)
4. Both comparisons `true` → return `true` at `L=2, R=2`
5. Entire tree is symmetric → return `true`

**Output:** `true`

If any mirrored nodes differ (e.g., rightmost leaf = 5), the function returns `false` immediately.

---

# Binary Tree Level Order Traversal (LeetCode 102)

## Overview

This code performs **level-order traversal** (Breadth-First Search) of a binary tree and returns an **array of arrays**, where each sub-array contains all node values at a particular level.

---

## Approach

1. **Breadth-First Search (BFS)** using a **queue**:

   * Start with the root node in the queue.
   * Process nodes **level by level**:

     * For each level, iterate over all nodes in the queue.
     * Collect their values in a temporary array.
     * Enqueue their children for the next level.
   * Repeat until the queue is empty.

2. **Alternative Approaches**

   * **DFS with level tracking:** Traverse recursively and append values to arrays corresponding to their depth.
   * **Iterative BFS with markers:** Use `null` or level counters to track level boundaries.

---

## Algorithm

1. If `root` is `null`, return `[]`.
2. Initialize `queue = [root]` and `ans = []`.
3. While `queue` is not empty:

   * `size = queue.length` (number of nodes at current level)
   * Initialize `cur = []` to store current level values
   * For `i = 0` to `size-1`:

     * `temp = queue.shift()`
     * Add `temp.val` to `cur`
     * If `temp.left != null`, enqueue `temp.left`
     * If `temp.right != null`, enqueue `temp.right`
   * Append `cur` to `ans`
4. Return `ans`

---

## Pseudocode

```
FUNCTION levelOrder(root):
    IF root == NULL THEN
        RETURN empty array []
    
    queue = [root]
    ans = []
    
    WHILE queue is not empty:
        size = LENGTH(queue)
        cur = []
        
        FOR i FROM 0 TO size-1:
            temp = DEQUEUE(queue)
            APPEND temp.val TO cur
            IF temp.left != NULL THEN ENQUEUE(temp.left)
            IF temp.right != NULL THEN ENQUEUE(temp.right)
        
        APPEND cur TO ans
    
    RETURN ans
```

**Commentary:**

* `queue` ensures nodes are processed in **FIFO order**, maintaining level structure.
* `size` determines the number of nodes in the current level.
* `cur` collects all node values for the current level.
* This method guarantees **O(n)** time complexity and **O(n)** space complexity, where `n` is the number of nodes.

---

## Flowchart

```
           [Start: root node]
                  |
        [Is root null?]---Yes--->[Return []]
                  |
                  No
                  |
           [Initialize queue with root]
                  |
        [While queue not empty]
                  |
         [size = queue.length]
                  |
           [cur = empty array]
                  |
      [For i = 0 to size-1]
                  |
      [Dequeue node temp from queue]
                  |
        [Add temp.val to cur array]
                  |
       [Enqueue temp.left if not null]
       [Enqueue temp.right if not null]
                  |
           [Append cur to ans]
                  |
          [Repeat while queue not empty]
                  |
               [Return ans]
```

---

## Dry Run Example

Input tree:

```
       3
      / \
     9  20
        / \
       15  7
```

**Step-by-step:**

1. Initialize: `queue = [3]`, `ans = []`

2. Level 1:

   * `size = 1`, `cur = []`
   * Dequeue 3 → `cur = [3]`
   * Enqueue 9 and 20 → `queue = [9,20]`
   * Append `cur` → `ans = [[3]]`

3. Level 2:

   * `size = 2`, `cur = []`
   * Dequeue 9 → `cur = [9]` (no children)
   * Dequeue 20 → `cur = [9,20]`
   * Enqueue 15 and 7 → `queue = [15,7]`
   * Append `cur` → `ans = [[3],[9,20]]`

4. Level 3:

   * `size = 2`, `cur = []`
   * Dequeue 15 → `cur = [15]` (no children)
   * Dequeue 7 → `cur = [15,7]` (no children)
   * Append `cur` → `ans = [[3],[9,20],[15,7]]`

5. Queue empty → return `ans = [[3],[9,20],[15,7]]`

This confirms **level-order traversal** produces arrays of node values per level.

---

# Binary Tree Level Order Traversal II (LeetCode 107)

## Overview

This code performs **level-order traversal** of a binary tree, similar to LeetCode 102, but returns the traversal **from bottom to top**.

* **Bottom-up Level Order Traversal:** Levels are collected from the **lowest level** up to the **root level**.

---

## Approach

1. **Breadth-First Search (BFS)** using a **queue**:

   * Traverse nodes **level by level** starting from the root.
   * Collect each level's node values in a temporary array.
   * Append levels to a result array.
   * After traversal, **reverse the result array** to get bottom-up order.

2. **Alternative Approaches**

   * **DFS with level tracking:** Traverse recursively, insert each level at the **beginning** of the result array.
   * **BFS iterative with deque:** Use a deque and push each level to the front for bottom-up order.

---

## Algorithm

1. If `root` is `null`, return `[]`.
2. Initialize `queue = [root]` and `ans = []`.
3. While `queue` is not empty:

   * `size = queue.length`
   * `cur = []` (to store current level values)
   * For `i = 0` to `size-1`:

     * `temp = queue.shift()`
     * Append `temp.val` to `cur`
     * If `temp.left != null`, enqueue `temp.left`
     * If `temp.right != null`, enqueue `temp.right`
   * Append `cur` to `ans`
4. Reverse `ans`
5. Return `ans`

---

## Pseudocode

```
FUNCTION levelOrderBottom(root):
    IF root == NULL THEN
        RETURN empty array []
    
    queue = [root]
    ans = []
    
    WHILE queue is not empty:
        size = LENGTH(queue)
        cur = []
        
        FOR i FROM 0 TO size-1:
            temp = DEQUEUE(queue)
            APPEND temp.val TO cur
            IF temp.left != NULL THEN ENQUEUE(temp.left)
            IF temp.right != NULL THEN ENQUEUE(temp.right)
        
        APPEND cur TO ans
    
    REVERSE ans
    RETURN ans
```

**Commentary:**

* Logic is almost identical to **level-order traversal**, with only the final **reverse** step differing.
* Using `ans.reverse()` flips the order of levels so that the **bottom-most level comes first**.
* Time complexity: **O(n)** (visiting each node once).
* Space complexity: **O(n)** (queue + result array).

---

## Flowchart

```
           [Start: root node]
                  |
        [Is root null?]---Yes--->[Return []]
                  |
                  No
                  |
           [Initialize queue with root]
                  |
        [While queue not empty]
                  |
         [size = queue.length]
                  |
           [cur = empty array]
                  |
      [For i = 0 to size-1]
                  |
      [Dequeue node temp from queue]
                  |
        [Add temp.val to cur array]
                  |
       [Enqueue temp.left if not null]
       [Enqueue temp.right if not null]
                  |
           [Append cur to ans]
                  |
          [Repeat while queue not empty]
                  |
           [Reverse ans array]
                  |
               [Return ans]
```

---

## Dry Run Example

Input tree:

```
       3
      / \
     9  20
        / \
       15  7
```

**Step-by-step:**

1. Initialize: `queue = [3]`, `ans = []`

2. Level 1:

   * `size = 1`, `cur = []`
   * Dequeue 3 → `cur = [3]`
   * Enqueue 9 and 20 → `queue = [9,20]`
   * Append `cur` → `ans = [[3]]`

3. Level 2:

   * `size = 2`, `cur = []`
   * Dequeue 9 → `cur = [9]` (no children)
   * Dequeue 20 → `cur = [9,20]`
   * Enqueue 15 and 7 → `queue = [15,7]`
   * Append `cur` → `ans = [[3],[9,20]]`

4. Level 3:

   * `size = 2`, `cur = []`
   * Dequeue 15 → `cur = [15]` (no children)
   * Dequeue 7 → `cur = [15,7]` (no children)
   * Append `cur` → `ans = [[3],[9,20],[15,7]]`

5. Queue empty → Reverse `ans` → `[[15,7],[9,20],[3]]`

**Output:** `[[15,7],[9,20],[3]]`

This confirms **bottom-up level-order traversal** is correctly implemented.

---

# Path Sum (LeetCode 112)

## Overview

This code determines whether a binary tree has a **root-to-leaf path** such that the sum of the node values along the path equals a given `targetSum`.

* **Root-to-leaf path:** A path starting from the root and ending at any leaf node (node with no children).

---

## Approach

1. **Recursive Depth-First Search (DFS)**

   * Base case 1: If node is `null`, return `false` (no path).
   * Base case 2: If node is a **leaf** and `node.val === targetSum`, return `true`.
   * Recursively check left and right subtrees with updated target:

     * `targetSum - node.val`
   * Return `true` if **either left or right** subtree has a valid path.

2. **Alternative Approaches**

   * **DFS with stack (iterative):** Maintain a stack of `(node, currentSum)` pairs.
   * **BFS with queue:** Traverse level by level while tracking the remaining sum.

---

## Algorithm

1. If `root` is `null`, return `false`.
2. If `root` is a leaf (`!root.left && !root.right`) and `root.val === targetSum`, return `true`.
3. Recursively call `hasPathSum` on left child with `targetSum - root.val`.
4. Recursively call `hasPathSum` on right child with `targetSum - root.val`.
5. Return `left || right`.

---

## Pseudocode

```
FUNCTION hasPathSum(root, targetSum):
    // No node → cannot have path
    IF root == NULL THEN
        RETURN false
    
    // Leaf node and value equals remaining target → path found
    IF root.left == NULL AND root.right == NULL AND root.val == targetSum THEN
        RETURN true
    
    // Recursively check left and right subtrees with reduced target
    leftCheck = hasPathSum(root.left, targetSum - root.val)
    rightCheck = hasPathSum(root.right, targetSum - root.val)
    
    // Return true if either subtree has valid path
    RETURN leftCheck OR rightCheck
```

**Commentary:**

* Each recursive call **reduces the target sum** by the current node value.
* Only paths that **end at a leaf** are valid.
* Short-circuits with `true` as soon as a valid path is found.

---

## Flowchart

```
           [Start: root node]
                  |
        [Is root null?]---Yes--->[Return false]
                  |
                  No
                  |
  [Is leaf node and root.val == targetSum?]---Yes--->[Return true]
                  |
                  No
                  |
   [Check left subtree with targetSum - root.val]
                  |
   [Check right subtree with targetSum - root.val]
                  |
       [Return left OR right result]
```

---

## Dry Run Example

Input tree:

```
       5
      / \
     4   8
    /   / \
   11  13  4
  /  \      \
 7    2      1
```

Target sum: `22`

**Step-by-step:**

1. Start at 5 → remaining sum = 22 - 5 = 17
2. Left subtree: 4 → remaining sum = 17 - 4 = 13
3. Left subtree: 11 → remaining sum = 13 - 11 = 2
4. Left child: 7 → remaining sum = 2 - 7 = -5 → not leaf match → false
5. Right child: 2 → remaining sum = 2 - 2 = 0 → leaf node → return `true`

Left subtree returned `true` → short-circuit → return `true` at root.

**Output:** `true`

This confirms that a **root-to-leaf path with sum 22 exists**: `5 → 4 → 11 → 2`.

---

# Path Sum II (LeetCode 113)

## Overview

This code finds **all root-to-leaf paths** in a binary tree where the sum of the node values equals a given `targetSum`.

* Unlike LeetCode 112, which returns a boolean, this **returns all valid paths** as arrays.
* **Root-to-leaf paths:** Paths starting from the root and ending at leaf nodes.

---

## Approach

1. **Recursive Depth-First Search (DFS)** with **backtracking**:

   * Maintain a **current path stack** (`pathStack`) to store nodes along the current path.
   * Maintain a **running sum** (`sum`) along the path.
   * Base case: If node is `null`, return.
   * Add current node value to `pathStack` and `sum`.
   * If leaf node and `sum === targetSum`, add a **copy of pathStack** to `ans`.
   * Recursively traverse left and right children.
   * **Backtrack:** Remove the last node from `pathStack` before returning.

2. **Key Concepts:**

   * **Backtracking:** Ensures the path is restored for sibling branches.
   * **Copy of pathStack:** Use `[...pathStack]` to avoid reference issues.

3. **Alternative Approaches:**

   * Iterative DFS using stack with `(node, path, currentSum)` tuples.
   * BFS with queue tracking paths and sums.

---

## Algorithm

1. Initialize `ans = []`.
2. Define recursive function `dfs(node, pathStack, sum)`:

   * If `node == null`, return.
   * Append `node.val` to `pathStack` and add to `sum`.
   * If `node` is a leaf and `sum === targetSum`, append a copy of `pathStack` to `ans`.
   * Recursively call `dfs(node.left, pathStack, sum)` and `dfs(node.right, pathStack, sum)`.
   * Pop last element from `pathStack` (backtracking).
3. Call `dfs(root, [], 0)`
4. Return `ans`.

---

## Pseudocode

```
FUNCTION pathSum(root, targetSum):
    ans = []

    FUNCTION dfs(node, pathStack, sum):
        IF node == NULL THEN
            RETURN
        
        // Add current node to path and sum
        APPEND node.val TO pathStack
        sum = sum + node.val

        // Check leaf and target sum
        IF node.left == NULL AND node.right == NULL AND sum == targetSum THEN
            APPEND COPY(pathStack) TO ans
        
        // Recur for left and right children
        dfs(node.left, pathStack, sum)
        dfs(node.right, pathStack, sum)

        // Backtrack: remove current node before returning
        POP last element FROM pathStack

    CALL dfs(root, [], 0)
    RETURN ans
```

**Commentary:**

* Backtracking is crucial; without `pathStack.pop()`, paths from previous branches would mix.
* `[...pathStack]` creates a **snapshot** of the current path for storage.
* The function explores **all paths** from root to leaves.

---

## Flowchart

```
          [Start: root node]
                  |
         [Is node null?]---Yes--->[Return]
                  |
                  No
                  |
      [Append node.val to pathStack]
                  |
       [Add node.val to running sum]
                  |
   [Is leaf node AND sum == targetSum?]---Yes--->[Append copy of pathStack to ans]
                  |
                  No
                  |
       [DFS left child with pathStack and sum]
       [DFS right child with pathStack and sum]
                  |
       [Backtrack: pop node.val from pathStack]
                  |
               [Return to previous node]
```

---

## Dry Run Example

Input tree:

```
       5
      / \
     4   8
    /   / \
   11  13  4
  /  \    / \
 7    2  5   1
```

Target sum: `22`

**Step-by-step (partial):**

1. Start at 5 → pathStack `[5]`, sum = 5
2. Left subtree 4 → pathStack `[5,4]`, sum = 9
3. Left subtree 11 → pathStack `[5,4,11]`, sum = 20
4. Left child 7 → sum = 27 → not match → backtrack → pathStack `[5,4,11]`
5. Right child 2 → sum = 22 → leaf → **add `[5,4,11,2]` to ans**
6. Backtrack → pathStack `[5,4]` → continue right subtree of root (8)
7. Repeat similarly → find `[5,8,4,5]` → add to ans

**Output:**

```
[[5,4,11,2],[5,8,4,5]]
```

This confirms all root-to-leaf paths with sum 22 are correctly found.

---

# Invert Binary Tree (LeetCode 226)

## Overview

This code **inverts a binary tree**, swapping every node’s left and right children.

* Essentially, the tree is mirrored across its root.
* Example:

Original:

```
    4
   / \
  2   7
 / \ / \
1  3 6  9
```

Inverted:

```
    4
   / \
  7   2
 / \ / \
9  6 3  1
```

---

## Approach

1. **Recursive Depth-First Search (DFS):**

   * For each node:

     * Swap its left and right children.
     * Recursively invert left and right subtrees.

2. **Alternative Approaches:**

   * **Iterative BFS:** Use a queue, swap children at each level.
   * **Iterative DFS:** Use a stack, swap children while traversing.

---

## Algorithm

1. Define recursive function `dfs(node)`:

   * If `node == null`, return.
   * Swap `node.left` and `node.right`.
   * Recursively call `dfs(node.left)` and `dfs(node.right)`.
2. Call `dfs(root)`
3. Return `root`.

---

## Pseudocode

```
FUNCTION invertTree(root):

    FUNCTION dfs(node):
        IF node == NULL THEN
            RETURN

        // Swap left and right children
        temp = node.left
        node.left = node.right
        node.right = temp

        // Recur for left and right subtrees
        dfs(node.left)
        dfs(node.right)

    CALL dfs(root)
    RETURN root
```

**Commentary:**

* `[node.left, node.right] = [node.right, node.left]` is a concise JS syntax for swapping.
* Recursion ensures **all nodes** are visited.
* Base case `node == null` prevents null pointer errors.

---

## Flowchart

```
           [Start: root node]
                  |
        [Is node null?]---Yes--->[Return]
                  |
                  No
                  |
     [Swap node.left and node.right]
                  |
       [DFS on node.left (new left)]
       [DFS on node.right (new right)]
                  |
               [Return node]
```

---

## Dry Run Example

Input tree:

```
    2
   / \
  1   3
```

**Step-by-step:**

1. `dfs(2)` → swap 1 and 3 → tree becomes:

```
    2
   / \
  3   1
```

2. `dfs(3)` → leaf node → swap `null` children → no change
3. `dfs(1)` → leaf node → swap `null` children → no change

**Output tree:**

```
    2
   / \
  3   1
```

This confirms the **binary tree is correctly inverted**.

---

# Diameter of Binary Tree (LeetCode 543)

## Overview

This code calculates the **diameter of a binary tree**, which is the length of the **longest path between any two nodes** in the tree.

* The path **may or may not pass through the root**.
* Length is measured in **edges** (not nodes).

Example:

```
       1
      / \
     2   3
    / \
   4   5
```

* Diameter = 3 (path 4 → 2 → 5 → 1 or 4 → 2 → 5).

---

## Approach

1. **Recursive DFS**:

   * For each node, compute the **height of left and right subtrees**.
   * **Local diameter at node** = `left height + right height`.
   * Keep a **global maximum** (`total`) to track the largest diameter seen.
   * Return `max(left height, right height) + 1` to parent (height of current node).

2. **Alternative Approaches:**

   * DFS returning both height and diameter for each subtree (tuple).
   * BFS-based approach with height computations for each node (less efficient).

---

## Algorithm

1. Initialize `total = 0`
2. Define `dfs(node)` to return height of subtree:

   * If `node == null`, return 0
   * `left = dfs(node.left)`
   * `right = dfs(node.right)`
   * Update `total = max(total, left + right)`
   * Return `max(left, right) + 1` (height of current node)
3. Call `dfs(root)`
4. Return `total`

---

## Pseudocode

```
FUNCTION diameterOfBinaryTree(root):
    total = 0

    FUNCTION dfs(node):
        IF node == NULL THEN
            RETURN 0

        leftHeight = dfs(node.left)
        rightHeight = dfs(node.right)

        // Update global diameter
        total = MAX(total, leftHeight + rightHeight)

        // Return height to parent
        RETURN MAX(leftHeight, rightHeight) + 1

    CALL dfs(root)
    RETURN total
```

**Commentary:**

* `left + right` counts **edges between leftmost and rightmost nodes through current node**.
* `dfs` simultaneously calculates **height** and **updates diameter**, making it efficient.
* Time complexity: **O(n)** (each node visited once)
* Space complexity: **O(h)** (recursion stack, h = tree height)

---

## Flowchart

```
           [Start: root node]
                  |
        [Is node null?]---Yes--->[Return 0]
                  |
                  No
                  |
        [DFS left subtree -> leftHeight]
        [DFS right subtree -> rightHeight]
                  |
        [Update total = max(total, leftHeight + rightHeight)]
                  |
        [Return max(leftHeight, rightHeight) + 1]
```

---

## Dry Run Example

Input tree:

```
       1
      / \
     2   3
    / \
   4   5
```

**Step-by-step:**

1. `dfs(4)` → leaf → returns 1
2. `dfs(5)` → leaf → returns 1
3. `dfs(2)` → left=1, right=1 → update total=1+1=2 → return height=2
4. `dfs(3)` → leaf → returns 1
5. `dfs(1)` → left=2, right=1 → update total=MAX(2, 2+1)=3 → return height=3

**Output:** `3`

This confirms the **diameter is correctly computed** as the longest path between any two nodes.
