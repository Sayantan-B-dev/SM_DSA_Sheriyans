# Left View of Binary Tree (GFG)

## Overview

This code finds the **left view** of a binary tree, i.e., the set of nodes visible when the tree is viewed **from the left side**.

* Only the **first node at each level** is included.

Example:

```
       1
      / \
     2   3
      \   \
       4   5
```

* Left view: `[1, 2, 4]`

---

## Approach

1. **Recursive Depth-First Search (DFS)** with **level tracking**:

   * Traverse the tree **pre-order**: root → left → right
   * Keep track of the **current level**.
   * Maintain an array `ans` to store the first node of each level.
   * If `level === ans.length`, it means this is the first node being visited at this level → push it to `ans`.
   * Recur for left child first, then right child.

2. **Alternative Approaches:**

   * **BFS (level-order traversal):** Take the first node of each level.
   * **Iterative DFS:** Stack with `(node, level)` pairs.

---

## Algorithm

1. Initialize `ans = []`
2. Define recursive `dfs(node, level)` function:

   * If `node == null`, return
   * If `level === ans.length`, append `node.data` to `ans`
   * Recur:

     * `dfs(node.left, level + 1)`
     * `dfs(node.right, level + 1)`
3. Call `dfs(root, 0)`
4. Return `ans`

---

## Pseudocode

```
FUNCTION leftView(root):
    ans = []

    FUNCTION dfs(node, level):
        IF node == NULL THEN
            RETURN

        // First node at this level
        IF level == LENGTH(ans) THEN
            APPEND node.data TO ans

        // Recur left first for leftmost nodes
        dfs(node.left, level + 1)
        dfs(node.right, level + 1)

    CALL dfs(root, 0)
    RETURN ans
```

**Commentary:**

* `level === ans.length` ensures only the **first node at a new level** is recorded.
* Pre-order traversal ensures **leftmost nodes are visited first**.
* Efficient: **O(n)** time, **O(h)** space (recursion stack), where `h` = height of tree.

---

## Flowchart

```
           [Start: root node, level=0]
                  |
        [Is node null?]---Yes--->[Return]
                  |
                  No
                  |
   [Is level == ans.length?]---Yes--->[Append node.data to ans]
                  |
                  No
                  |
       [DFS on node.left, level+1]
       [DFS on node.right, level+1]
                  |
               [Return]
```

---

## Dry Run Example

Input tree:

```
       1
      / \
     2   3
      \   \
       4   5
```

**Step-by-step:**

1. `dfs(1,0)` → `level=0`, ans length=0 → append 1 → ans `[1]`
2. Left: `dfs(2,1)` → `level=1`, ans length=1 → append 2 → ans `[1,2]`
3. Left child of 2 → null → return
4. Right child: `dfs(4,2)` → `level=2`, ans length=2 → append 4 → ans `[1,2,4]`
5. Right: `dfs(3,1)` → `level=1`, ans length=3 → already filled → skip
6. Right child: `dfs(5,2)` → `level=2`, ans length=3 → already filled → skip

**Output:** `[1,2,4]`

This confirms the **left view is correctly computed**.

---

# Right View of Binary Tree (GFG)

## Overview

This code finds the **right view** of a binary tree, i.e., the set of nodes visible when the tree is viewed **from the right side**.

* Only the **first node at each level** (from the right) is included.

Example:

```
       1
      / \
     2   3
      \   \
       4   5
```

* Right view: `[1, 3, 5]`

---

## Approach

1. **Recursive Depth-First Search (DFS)** with **level tracking**:

   * Traverse the tree in **root → right → left** order.
   * Keep track of the **current level**.
   * Maintain an array `ans` to store the first node of each level.
   * If `level === ans.length`, it means this is the **first node at this level** → push it to `ans`.
   * Recur for **right child first**, then left child.

2. **Alternative Approaches:**

   * **BFS (level-order traversal):** Take the last node of each level.
   * **Iterative DFS:** Stack with `(node, level)` pairs, traverse right first.

---

## Algorithm

1. Initialize `ans = []`
2. Define recursive `dfs(node, level)` function:

   * If `node == null`, return
   * If `level === ans.length`, append `node.data` to `ans`
   * Recur:

     * `dfs(node.right, level + 1)`
     * `dfs(node.left, level + 1)`
3. Call `dfs(root, 0)`
4. Return `ans`

---

## Pseudocode

```
FUNCTION rightView(root):
    ans = []

    FUNCTION dfs(node, level):
        IF node == NULL THEN
            RETURN

        // First node at this level (from right)
        IF level == LENGTH(ans) THEN
            APPEND node.data TO ans

        // Recur right first for rightmost nodes
        dfs(node.right, level + 1)
        dfs(node.left, level + 1)

    CALL dfs(root, 0)
    RETURN ans
```

**Commentary:**

* `level === ans.length` ensures only the **first node at a new level** is recorded.
* Pre-order traversal starting with **right child** ensures **rightmost nodes are visited first**.
* Efficient: **O(n)** time, **O(h)** space (recursion stack), where `h` = height of tree.

---

## Flowchart

```
           [Start: root node, level=0]
                  |
        [Is node null?]---Yes--->[Return]
                  |
                  No
                  |
   [Is level == ans.length?]---Yes--->[Append node.data to ans]
                  |
                  No
                  |
       [DFS on node.right, level+1]
       [DFS on node.left, level+1]
                  |
               [Return]
```

---

## Dry Run Example

Input tree:

```
       1
      / \
     2   3
      \   \
       4   5
```

**Step-by-step:**

1. `dfs(1,0)` → `level=0`, ans length=0 → append 1 → ans `[1]`
2. Right: `dfs(3,1)` → `level=1`, ans length=1 → append 3 → ans `[1,3]`
3. Right child of 3: `dfs(5,2)` → `level=2`, ans length=2 → append 5 → ans `[1,3,5]`
4. Left child of 3 → null → return
5. Left: `dfs(2,1)` → `level=1`, ans length=3 → already filled → skip
6. Right child: `dfs(4,2)` → `level=2`, ans length=3 → already filled → skip

**Output:** `[1,3,5]`

This confirms the **right view is correctly computed**.

---

# Top View of Binary Tree (GFG)

## Overview

This code finds the **top view** of a binary tree, i.e., the set of nodes visible when the tree is viewed **from above**.

* For each **horizontal distance (HD)** from root, only the **first node encountered at that HD** in level order is included.
* **Horizontal distance (HD):**

  * Root → 0
  * Left child → HD - 1
  * Right child → HD + 1

Example:

```
        1
       / \
      2   3
       \   \
        4   5
```

* Top view: `[2,1,3,5]`

---

## Approach

1. **Level-order traversal (BFS) with horizontal distance tracking:**

   * Use a **queue** to traverse nodes level by level.
   * Maintain a **map**: `HD → first node.data at that HD`.
   * For each node:

     * If HD not in map → record node.data
     * Enqueue left child with HD-1, right child with HD+1
   * After BFS, sort HD keys and return corresponding node values.

2. **Key Concepts:**

   * Using **Map** ensures **first node at each HD** is recorded.
   * Level-order ensures **topmost nodes are visited first**.

---

## Algorithm

1. Define a `Pair(node, hd)` class to store node and its horizontal distance.
2. Initialize:

   * Queue `q = [Pair(root, 0)]`
   * Map `map = {}`
3. While queue not empty:

   * Pop front node `temp`
   * If `map` does not have `temp.hd`, set `map[temp.hd] = temp.node.data`
   * If left child exists → enqueue `Pair(left, hd-1)`
   * If right child exists → enqueue `Pair(right, hd+1)`
4. Sort map keys, push corresponding values to `ans`
5. Return `ans`

---

## Pseudocode

```
CLASS Pair:
    node
    hd

FUNCTION topView(root):
    IF root == NULL THEN RETURN []

    q = empty queue
    map = empty map
    ans = []

    ENQUEUE Pair(root, 0) INTO q

    WHILE q not empty:
        temp = DEQUEUE from q

        // Record first node at this horizontal distance
        IF temp.hd not in map:
            map[temp.hd] = temp.node.data

        // Enqueue children with updated horizontal distances
        IF temp.node.left != NULL:
            ENQUEUE Pair(temp.node.left, temp.hd - 1)
        IF temp.node.right != NULL:
            ENQUEUE Pair(temp.node.right, temp.hd + 1)

    sortedKeys = SORT keys of map in ascending order
    FOR key IN sortedKeys:
        APPEND map[key] TO ans

    RETURN ans
```

**Commentary:**

* Horizontal distance tracking is **critical** for top view.
* BFS ensures **topmost node at each HD** is visited first.
* Sorting HDs ensures **left-to-right order** in final answer.
* Time complexity: **O(n log n)** (sorting keys), space complexity: **O(n)**

---

## Flowchart

```
           [Start: root node]
                  |
        [Is root null?]---Yes--->[Return []]
                  |
                  No
                  |
        [Enqueue Pair(root,0) into queue]
                  |
        [While queue not empty]
                  |
           [Dequeue node]
                  |
      [Is hd in map?]---No--->[map[hd] = node.data]
                  |
                  Yes
                  |
 [Enqueue left child with hd-1 if exists]
 [Enqueue right child with hd+1 if exists]
                  |
        [After BFS, sort map keys]
                  |
     [Append map values in sorted order to ans]
                  |
               [Return ans]
```

---

## Dry Run Example

Input tree:

```
        1
       / \
      2   3
       \   \
        4   5
```

**Step-by-step:**

1. Start: queue = `[Pair(1,0)]`, map = `{}`
2. Dequeue 1, HD=0 → map[0] = 1
3. Enqueue left: Pair(2,-1), right: Pair(3,1)
4. Dequeue 2, HD=-1 → map[-1] = 2
5. Left null, right: Pair(4,0) → queue = [Pair(3,1), Pair(4,0)]
6. Dequeue 3, HD=1 → map[1] = 3
7. Left null, right: Pair(5,2) → queue = [Pair(4,0), Pair(5,2)]
8. Dequeue 4, HD=0 → map already has 0 → skip
9. Dequeue 5, HD=2 → map[2] = 5
10. Sort keys: [-1,0,1,2] → ans = [2,1,3,5]

**Output:** `[2,1,3,5]`

This confirms the **top view is correctly computed**.

---

# Bottom View of Binary Tree (GFG)

## Overview

This code finds the **bottom view** of a binary tree, i.e., the set of nodes visible when the tree is viewed **from below**.

* For each **horizontal distance (HD)** from root, the **last node encountered at that HD** in level order is included.
* Unlike top view, nodes at lower levels **overwrite** upper-level nodes at the same HD.

Example:

```
        1
       / \
      2   3
       \   \
        4   5
```

* Bottom view: `[2,4,3,5]`

---

## Approach

1. **Level-order traversal (BFS) with horizontal distance tracking:**

   * Use a **queue** to traverse nodes level by level.
   * Maintain a **map**: `HD → node.data`
   * For each node:

     * Update `map[HD] = node.data` (overwrites previous nodes at same HD)
     * Enqueue left child with HD-1, right child with HD+1
   * After BFS, sort HD keys and return corresponding node values.

2. **Key Concepts:**

   * Using **Map** ensures the **most recent node at each HD** is stored (bottommost).
   * Level-order traversal guarantees **nodes at lower levels overwrite upper nodes**.

---

## Algorithm

1. Define a `Pair(node, hd)` class to store node and its horizontal distance.
2. Initialize:

   * Queue `q = [Pair(root, 0)]`
   * Map `map = {}`
3. While queue not empty:

   * Pop front node `temp`
   * Set `map[temp.hd] = temp.node.data` (overwrite previous)
   * If left child exists → enqueue `Pair(left, hd-1)`
   * If right child exists → enqueue `Pair(right, hd+1)`
4. Sort map keys, push corresponding values to `ans`
5. Return `ans`

---

## Pseudocode

```
CLASS Pair:
    node
    hd

FUNCTION bottomView(root):
    IF root == NULL THEN RETURN []

    q = empty queue
    map = empty map
    ans = []

    ENQUEUE Pair(root, 0) INTO q

    WHILE q not empty:
        temp = DEQUEUE from q

        // Overwrite value at this horizontal distance
        map[temp.hd] = temp.node.data

        // Enqueue children with updated horizontal distances
        IF temp.node.left != NULL:
            ENQUEUE Pair(temp.node.left, temp.hd - 1)
        IF temp.node.right != NULL:
            ENQUEUE Pair(temp.node.right, temp.hd + 1)

    sortedKeys = SORT keys of map in ascending order
    FOR key IN sortedKeys:
        APPEND map[key] TO ans

    RETURN ans
```

**Commentary:**

* BFS ensures **nodes at deeper levels replace earlier nodes at same HD**.
* Sorting HDs ensures **left-to-right order** in final answer.
* Time complexity: **O(n log n)** (for sorting HDs), space complexity: **O(n)**

---

## Flowchart

```
           [Start: root node]
                  |
        [Is root null?]---Yes--->[Return []]
                  |
                  No
                  |
        [Enqueue Pair(root,0) into queue]
                  |
        [While queue not empty]
                  |
           [Dequeue node]
                  |
      [Set map[hd] = node.data] //overwrite previous
                  |
 [Enqueue left child with hd-1 if exists]
 [Enqueue right child with hd+1 if exists]
                  |
        [After BFS, sort map keys]
                  |
     [Append map values in sorted order to ans]
                  |
               [Return ans]
```

---

## Dry Run Example

Input tree:

```
        1
       / \
      2   3
       \   \
        4   5
```

**Step-by-step:**

1. Start: queue = `[Pair(1,0)]`, map = `{}`
2. Dequeue 1, HD=0 → map[0] = 1
3. Enqueue left: Pair(2,-1), right: Pair(3,1)
4. Dequeue 2, HD=-1 → map[-1] = 2
5. Left null, right: Pair(4,0) → queue = [Pair(3,1), Pair(4,0)]
6. Dequeue 3, HD=1 → map[1] = 3
7. Left null, right: Pair(5,2) → queue = [Pair(4,0), Pair(5,2)]
8. Dequeue 4, HD=0 → map[0] = 4 (overwrite)
9. Dequeue 5, HD=2 → map[2] = 5
10. Sort keys: [-1,0,1,2] → ans = [2,4,3,5]

**Output:** `[2,4,3,5]`

This confirms the **bottom view is correctly computed**.

---

# Lowest Common Ancestor of a Binary Tree (LeetCode 236)

## Overview

This problem finds the **lowest common ancestor (LCA)** of two nodes `p` and `q` in a binary tree.

* **LCA** is the **deepest node** that has both `p` and `q` as descendants (a node can be a descendant of itself).

Example:

```
        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4
```

* LCA of 5 and 1 → 3
* LCA of 6 and 4 → 5

---

## Approach

1. **Recursive DFS:**

   * Base cases:

     * If `root == null` → return null
     * If `root == p` or `root == q` → return root
   * Recur for left and right subtrees:

     * `left = dfs(root.left)`
     * `right = dfs(root.right)`
   * **Decision:**

     * If both `left` and `right` are non-null → `root` is LCA
     * Else → return non-null child (`left` or `right`)

2. **Key Concepts:**

   * Post-order traversal ensures **child nodes are processed first**.
   * The first node where both left and right return non-null is the **lowest common ancestor**.

---

## Algorithm

1. Define `dfs(node)` function:

   * If `node == null` → return null
   * If `node == p` or `node == q` → return node
   * `left = dfs(node.left)`
   * `right = dfs(node.right)`
   * If `left` and `right` are both non-null → return `node`
   * Else → return `left` if `left != null`, otherwise `right`

2. Call `dfs(root)`

3. Return result

---

## Pseudocode

```
FUNCTION lowestCommonAncestor(root, p, q):

    IF root == NULL THEN
        RETURN NULL

    IF root == p OR root == q THEN
        RETURN root

    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)

    // If p and q found in different subtrees
    IF left != NULL AND right != NULL THEN
        RETURN root

    // Else return non-null child
    IF left != NULL THEN
        RETURN left
    ELSE
        RETURN right
```

**Commentary:**

* Base cases handle **null nodes** and **when root itself is p or q**.
* Returning non-null child bubbles up the ancestor node.
* Time complexity: **O(n)**, Space complexity: **O(h)** (recursion stack)

---

## Flowchart

```
           [Start: root node]
                  |
        [Is root null?]---Yes--->[Return null]
                  |
        [Is root == p or root == q?]---Yes--->[Return root]
                  |
                  No
                  |
       [DFS left subtree -> left]
       [DFS right subtree -> right]
                  |
 [Are left and right both non-null?]---Yes--->[Return root (LCA)]
                  |
                  No
                  |
 [Return left if left!=null else right]
```

---

## Dry Run Example

Input tree:

```
        3
       / \
      5   1
     / \
    6   2
       / \
      7   4
```

Find LCA of 7 and 4:

1. `dfs(3)` → neither p nor q
2. Left: `dfs(5)`

   * Left: `dfs(6)` → null
   * Right: `dfs(2)`

     * Left: `dfs(7)` → returns 7
     * Right: `dfs(4)` → returns 4
     * Both left and right non-null → return 2 as LCA of 7 and 4
3. Right: `dfs(1)` → null
4. Back at root: left=2, right=null → return left=2

**Output:** `2`

This confirms the **LCA is correctly identified**.

---

# Path Sum III (LeetCode 437)

## Overview

This problem counts the **number of paths in a binary tree** that sum up to a given `targetSum`.

* A path **does not need to start at the root or end at a leaf**, but it **must go downward** (parent → child).

Example:

```
        10
       /  \
      5   -3
     / \    \
    3   2    11
   / \   \
  3  -2   1
```

* `targetSum = 8` → Paths: `[5,3]`, `[5,2,1]`, `[10,-3,1]`, `[3,5]` etc.
* Total paths = 3

---

## Approach

1. **Recursive DFS with prefix sum map:**

   * Maintain a **running sum** from root to current node.
   * Keep a **hash map**: `prefixSum → frequency`
   * For current node:

     * `currentSum += node.val`
     * Number of valid paths ending at this node: `map[currentSum - targetSum]`
     * Increment `map[currentSum]`
     * Recur for left and right children
     * After recursion, decrement `map[currentSum]` (backtracking)

2. **Alternative simpler approach (less efficient):**

   * For each node, start DFS counting all downward paths from that node
   * Sum up all paths

3. **Key Concepts:**

   * Using **prefix sum map** reduces time complexity from **O(n²) → O(n)**
   * Backtracking ensures **no overlapping count** between separate paths

---

## Algorithm

1. Initialize `map = {0:1}` (base case: sum=0 has one occurrence)
2. Define recursive function `dfs(node, currentSum)`

   * If `node == null` → return 0
   * `currentSum += node.val`
   * `count = map.get(currentSum - targetSum, 0)` → number of valid paths ending here
   * `map[currentSum] += 1`
   * `count += dfs(node.left, currentSum)`
   * `count += dfs(node.right, currentSum)`
   * `map[currentSum] -= 1` (backtrack)
   * Return `count`
3. Call `dfs(root, 0)`
4. Return total count

---

## Pseudocode

```
FUNCTION pathSum(root, targetSum):
    map = {0:1}  // prefix sum map

    FUNCTION dfs(node, currentSum):
        IF node == NULL THEN
            RETURN 0

        currentSum += node.val

        // Number of paths ending at current node
        count = map.get(currentSum - targetSum, 0)

        // Add current prefix sum to map
        map[currentSum] = map.get(currentSum,0) + 1

        // Recurse left and right
        count += dfs(node.left, currentSum)
        count += dfs(node.right, currentSum)

        // Backtrack
        map[currentSum] -= 1

        RETURN count

    RETURN dfs(root, 0)
```

**Commentary:**

* `currentSum - targetSum` gives the sum of a previous prefix that would make the path sum equal `targetSum`.
* Backtracking (`map[currentSum] -= 1`) ensures **paths from other branches do not interfere**.
* Efficient: **O(n)** time, **O(n)** space (for map and recursion stack).

---

## Flowchart

```
           [Start: root node, currentSum=0]
                  |
        [Is node null?]---Yes--->[Return 0]
                  |
                  No
                  |
       [currentSum += node.val]
                  |
 [count = map.get(currentSum - targetSum,0)]
                  |
       [map[currentSum] += 1]
                  |
   [DFS left subtree -> add to count]
   [DFS right subtree -> add to count]
                  |
       [map[currentSum] -= 1] // backtrack
                  |
               [Return count]
```

---

## Dry Run Example

Input tree:

```
        10
       /  \
      5   -3
     / \    \
    3   2    11
   / \   \
  3  -2   1
```

`targetSum = 8`

**Step-by-step:**

1. Start at root 10 → `currentSum=10` → `map={0:1,10:1}` → `count=0`
2. Left child 5 → `currentSum=15` → `map={0:1,10:1,15:1}` → `count=0`
3. Left child 3 → `currentSum=18` → `count=map[18-8]=map[10]=1` → path `[10,5,3]` → count=1
4. Left 3 → `currentSum=21` → `count=0` → leaf → backtrack
5. Right -2 → `currentSum=16` → `count=0` → backtrack
6. Backtrack 3 → remove 18 from map
7. Right child 2 → `currentSum=17` → `count=map[17-8]=map[9]=0`
8. Right 1 → `currentSum=18` → `count=map[10]=1` → path `[5,2,1]` → count=1
9. Backtrack right branch → decrement map entries
10. Right child -3 → `currentSum=7` → count=0
11. Right 11 → `currentSum=18` → `count=map[10]=1` → path `[10,-3,11]` → count=1

**Total paths = 3**

This confirms **all valid paths summing to targetSum are counted correctly**.

---

# Construct Binary Tree from Preorder and Inorder Traversal (LeetCode 105)

## Overview

This problem reconstructs a binary tree given its **preorder** and **inorder** traversals.

* **Preorder:** `[root, left subtree, right subtree]`
* **Inorder:** `[left subtree, root, right subtree]`

Example:

```
Preorder: [3,9,20,15,7]
Inorder:  [9,3,15,20,7]
```

* Output tree:

```
        3
       / \
      9  20
         / \
        15  7
```

---

## Approach

1. **Recursive construction using indexes:**

   * **Preorder array** gives the **root node** at each recursion.
   * **Inorder array** allows **splitting into left and right subtrees** using the root's index.
   * Recur on left and right subtrees with appropriate slices.

2. **Steps:**

   * Take current root from `preorder[preIndex]`
   * Find root in inorder array → index `inIndex`
   * Left subtree → inorder[ start .. inIndex-1 ]
   * Right subtree → inorder[ inIndex+1 .. end ]
   * Recur for left, then right
   * Use **hash map** for inorder indices to speed up lookup (O(1))

3. **Key Concepts:**

   * Preorder provides **root order**
   * Inorder provides **subtree boundaries**
   * Recursion builds **subtrees bottom-up**

---

## Algorithm

1. Initialize `preIndex = 0`
2. Build map `inorderMap` → value → index
3. Define `buildTreeHelper(inStart, inEnd)`

   * Base case: if inStart > inEnd → return null
   * rootVal = preorder[preIndex] → create node
   * Increment preIndex
   * rootIndex = inorderMap[rootVal]
   * root.left = buildTreeHelper(inStart, rootIndex-1)
   * root.right = buildTreeHelper(rootIndex+1, inEnd)
   * Return root
4. Call `buildTreeHelper(0, inorder.length-1)`

---

## Pseudocode

```
FUNCTION buildTree(preorder, inorder):
    preIndex = 0
    inorderMap = {} // value -> index
    FOR i = 0 TO inorder.length-1:
        inorderMap[inorder[i]] = i

    FUNCTION buildTreeHelper(inStart, inEnd):
        IF inStart > inEnd THEN
            RETURN NULL

        rootVal = preorder[preIndex]
        CREATE node with rootVal
        preIndex += 1

        rootIndex = inorderMap[rootVal]

        node.left = buildTreeHelper(inStart, rootIndex-1)
        node.right = buildTreeHelper(rootIndex+1, inEnd)

        RETURN node

    RETURN buildTreeHelper(0, inorder.length-1)
```

**Commentary:**

* `preIndex` keeps track of **current root in preorder**
* `inorderMap` allows **O(1) lookup** of root index
* Recursion divides the problem into **smaller left and right subtree constructions**
* Time complexity: **O(n)**, Space complexity: **O(n)**

---

## Flowchart

```
           [Start: inStart, inEnd]
                  |
        [Is inStart > inEnd?]---Yes--->[Return NULL]
                  |
                  No
                  |
         rootVal = preorder[preIndex]
         CREATE node(rootVal)
         preIndex += 1
                  |
         rootIndex = inorderMap[rootVal]
                  |
   [Build left subtree -> buildTreeHelper(inStart, rootIndex-1)]
   [Build right subtree -> buildTreeHelper(rootIndex+1, inEnd)]
                  |
               [Return node]
```

---

## Dry Run Example

Input:

```
Preorder: [3,9,20,15,7]
Inorder:  [9,3,15,20,7]
```

1. preIndex=0 → root=3
2. rootIndex in inorder=1
3. Left subtree: inorder[0..0] → root=9

   * No left/right children → return 9
4. Right subtree: inorder[2..4] → root=20 (preIndex=2)

   * Left: inorder[2..2] → root=15 → no children
   * Right: inorder[4..4] → root=7 → no children

**Constructed Tree:**

```
        3
       / \
      9  20
         / \
        15  7
```

This confirms the tree is **reconstructed correctly**.
