# Left View of Binary Tree (GFG)

## Overview

This code finds the **left view** of a binary tree, i.e., the set of nodes visible when the tree is viewed **from the left side**.

* Only the **first node at each level** is included.

Example:

```
       1
      / \
     2   3
      \   \
       4   5
```

* Left view: `[1, 2, 4]`

---

## Approach

1. **Recursive Depth-First Search (DFS)** with **level tracking**:

   * Traverse the tree **pre-order**: root → left → right
   * Keep track of the **current level**.
   * Maintain an array `ans` to store the first node of each level.
   * If `level === ans.length`, it means this is the first node being visited at this level → push it to `ans`.
   * Recur for left child first, then right child.

2. **Alternative Approaches:**

   * **BFS (level-order traversal):** Take the first node of each level.
   * **Iterative DFS:** Stack with `(node, level)` pairs.

---

## Algorithm

1. Initialize `ans = []`
2. Define recursive `dfs(node, level)` function:

   * If `node == null`, return
   * If `level === ans.length`, append `node.data` to `ans`
   * Recur:

     * `dfs(node.left, level + 1)`
     * `dfs(node.right, level + 1)`
3. Call `dfs(root, 0)`
4. Return `ans`

---

## Pseudocode

```
FUNCTION leftView(root):
    ans = []

    FUNCTION dfs(node, level):
        IF node == NULL THEN
            RETURN

        // First node at this level
        IF level == LENGTH(ans) THEN
            APPEND node.data TO ans

        // Recur left first for leftmost nodes
        dfs(node.left, level + 1)
        dfs(node.right, level + 1)

    CALL dfs(root, 0)
    RETURN ans
```

**Commentary:**

* `level === ans.length` ensures only the **first node at a new level** is recorded.
* Pre-order traversal ensures **leftmost nodes are visited first**.
* Efficient: **O(n)** time, **O(h)** space (recursion stack), where `h` = height of tree.

---

## Flowchart

```
           [Start: root node, level=0]
                  |
        [Is node null?]---Yes--->[Return]
                  |
                  No
                  |
   [Is level == ans.length?]---Yes--->[Append node.data to ans]
                  |
                  No
                  |
       [DFS on node.left, level+1]
       [DFS on node.right, level+1]
                  |
               [Return]
```

---

## Dry Run Example

Input tree:

```
       1
      / \
     2   3
      \   \
       4   5
```

**Step-by-step:**

1. `dfs(1,0)` → `level=0`, ans length=0 → append 1 → ans `[1]`
2. Left: `dfs(2,1)` → `level=1`, ans length=1 → append 2 → ans `[1,2]`
3. Left child of 2 → null → return
4. Right child: `dfs(4,2)` → `level=2`, ans length=2 → append 4 → ans `[1,2,4]`
5. Right: `dfs(3,1)` → `level=1`, ans length=3 → already filled → skip
6. Right child: `dfs(5,2)` → `level=2`, ans length=3 → already filled → skip

**Output:** `[1,2,4]`

This confirms the **left view is correctly computed**.

---

# Right View of Binary Tree (GFG)

## Overview

This code finds the **right view** of a binary tree, i.e., the set of nodes visible when the tree is viewed **from the right side**.

* Only the **first node at each level** (from the right) is included.

Example:

```
       1
      / \
     2   3
      \   \
       4   5
```

* Right view: `[1, 3, 5]`

---

## Approach

1. **Recursive Depth-First Search (DFS)** with **level tracking**:

   * Traverse the tree in **root → right → left** order.
   * Keep track of the **current level**.
   * Maintain an array `ans` to store the first node of each level.
   * If `level === ans.length`, it means this is the **first node at this level** → push it to `ans`.
   * Recur for **right child first**, then left child.

2. **Alternative Approaches:**

   * **BFS (level-order traversal):** Take the last node of each level.
   * **Iterative DFS:** Stack with `(node, level)` pairs, traverse right first.

---

## Algorithm

1. Initialize `ans = []`
2. Define recursive `dfs(node, level)` function:

   * If `node == null`, return
   * If `level === ans.length`, append `node.data` to `ans`
   * Recur:

     * `dfs(node.right, level + 1)`
     * `dfs(node.left, level + 1)`
3. Call `dfs(root, 0)`
4. Return `ans`

---

## Pseudocode

```
FUNCTION rightView(root):
    ans = []

    FUNCTION dfs(node, level):
        IF node == NULL THEN
            RETURN

        // First node at this level (from right)
        IF level == LENGTH(ans) THEN
            APPEND node.data TO ans

        // Recur right first for rightmost nodes
        dfs(node.right, level + 1)
        dfs(node.left, level + 1)

    CALL dfs(root, 0)
    RETURN ans
```

**Commentary:**

* `level === ans.length` ensures only the **first node at a new level** is recorded.
* Pre-order traversal starting with **right child** ensures **rightmost nodes are visited first**.
* Efficient: **O(n)** time, **O(h)** space (recursion stack), where `h` = height of tree.

---

## Flowchart

```
           [Start: root node, level=0]
                  |
        [Is node null?]---Yes--->[Return]
                  |
                  No
                  |
   [Is level == ans.length?]---Yes--->[Append node.data to ans]
                  |
                  No
                  |
       [DFS on node.right, level+1]
       [DFS on node.left, level+1]
                  |
               [Return]
```

---

## Dry Run Example

Input tree:

```
       1
      / \
     2   3
      \   \
       4   5
```

**Step-by-step:**

1. `dfs(1,0)` → `level=0`, ans length=0 → append 1 → ans `[1]`
2. Right: `dfs(3,1)` → `level=1`, ans length=1 → append 3 → ans `[1,3]`
3. Right child of 3: `dfs(5,2)` → `level=2`, ans length=2 → append 5 → ans `[1,3,5]`
4. Left child of 3 → null → return
5. Left: `dfs(2,1)` → `level=1`, ans length=3 → already filled → skip
6. Right child: `dfs(4,2)` → `level=2`, ans length=3 → already filled → skip

**Output:** `[1,3,5]`

This confirms the **right view is correctly computed**.

---

# Top View of Binary Tree (GFG)

## Overview

This code finds the **top view** of a binary tree, i.e., the set of nodes visible when the tree is viewed **from above**.

* For each **horizontal distance (HD)** from root, only the **first node encountered at that HD** in level order is included.
* **Horizontal distance (HD):**

  * Root → 0
  * Left child → HD - 1
  * Right child → HD + 1

Example:

```
        1
       / \
      2   3
       \   \
        4   5
```

* Top view: `[2,1,3,5]`

---

## Approach

1. **Level-order traversal (BFS) with horizontal distance tracking:**

   * Use a **queue** to traverse nodes level by level.
   * Maintain a **map**: `HD → first node.data at that HD`.
   * For each node:

     * If HD not in map → record node.data
     * Enqueue left child with HD-1, right child with HD+1
   * After BFS, sort HD keys and return corresponding node values.

2. **Key Concepts:**

   * Using **Map** ensures **first node at each HD** is recorded.
   * Level-order ensures **topmost nodes are visited first**.

---

## Algorithm

1. Define a `Pair(node, hd)` class to store node and its horizontal distance.
2. Initialize:

   * Queue `q = [Pair(root, 0)]`
   * Map `map = {}`
3. While queue not empty:

   * Pop front node `temp`
   * If `map` does not have `temp.hd`, set `map[temp.hd] = temp.node.data`
   * If left child exists → enqueue `Pair(left, hd-1)`
   * If right child exists → enqueue `Pair(right, hd+1)`
4. Sort map keys, push corresponding values to `ans`
5. Return `ans`

---

## Pseudocode

```
CLASS Pair:
    node
    hd

FUNCTION topView(root):
    IF root == NULL THEN RETURN []

    q = empty queue
    map = empty map
    ans = []

    ENQUEUE Pair(root, 0) INTO q

    WHILE q not empty:
        temp = DEQUEUE from q

        // Record first node at this horizontal distance
        IF temp.hd not in map:
            map[temp.hd] = temp.node.data

        // Enqueue children with updated horizontal distances
        IF temp.node.left != NULL:
            ENQUEUE Pair(temp.node.left, temp.hd - 1)
        IF temp.node.right != NULL:
            ENQUEUE Pair(temp.node.right, temp.hd + 1)

    sortedKeys = SORT keys of map in ascending order
    FOR key IN sortedKeys:
        APPEND map[key] TO ans

    RETURN ans
```

**Commentary:**

* Horizontal distance tracking is **critical** for top view.
* BFS ensures **topmost node at each HD** is visited first.
* Sorting HDs ensures **left-to-right order** in final answer.
* Time complexity: **O(n log n)** (sorting keys), space complexity: **O(n)**

---

## Flowchart

```
           [Start: root node]
                  |
        [Is root null?]---Yes--->[Return []]
                  |
                  No
                  |
        [Enqueue Pair(root,0) into queue]
                  |
        [While queue not empty]
                  |
           [Dequeue node]
                  |
      [Is hd in map?]---No--->[map[hd] = node.data]
                  |
                  Yes
                  |
 [Enqueue left child with hd-1 if exists]
 [Enqueue right child with hd+1 if exists]
                  |
        [After BFS, sort map keys]
                  |
     [Append map values in sorted order to ans]
                  |
               [Return ans]
```

---

## Dry Run Example

Input tree:

```
        1
       / \
      2   3
       \   \
        4   5
```

**Step-by-step:**

1. Start: queue = `[Pair(1,0)]`, map = `{}`
2. Dequeue 1, HD=0 → map[0] = 1
3. Enqueue left: Pair(2,-1), right: Pair(3,1)
4. Dequeue 2, HD=-1 → map[-1] = 2
5. Left null, right: Pair(4,0) → queue = [Pair(3,1), Pair(4,0)]
6. Dequeue 3, HD=1 → map[1] = 3
7. Left null, right: Pair(5,2) → queue = [Pair(4,0), Pair(5,2)]
8. Dequeue 4, HD=0 → map already has 0 → skip
9. Dequeue 5, HD=2 → map[2] = 5
10. Sort keys: [-1,0,1,2] → ans = [2,1,3,5]

**Output:** `[2,1,3,5]`

This confirms the **top view is correctly computed**.

---

# Bottom View of Binary Tree (GFG)

## Overview

This code finds the **bottom view** of a binary tree, i.e., the set of nodes visible when the tree is viewed **from below**.

* For each **horizontal distance (HD)** from root, the **last node encountered at that HD** in level order is included.
* Unlike top view, nodes at lower levels **overwrite** upper-level nodes at the same HD.

Example:

```
        1
       / \
      2   3
       \   \
        4   5
```

* Bottom view: `[2,4,3,5]`

---

## Approach

1. **Level-order traversal (BFS) with horizontal distance tracking:**

   * Use a **queue** to traverse nodes level by level.
   * Maintain a **map**: `HD → node.data`
   * For each node:

     * Update `map[HD] = node.data` (overwrites previous nodes at same HD)
     * Enqueue left child with HD-1, right child with HD+1
   * After BFS, sort HD keys and return corresponding node values.

2. **Key Concepts:**

   * Using **Map** ensures the **most recent node at each HD** is stored (bottommost).
   * Level-order traversal guarantees **nodes at lower levels overwrite upper nodes**.

---

## Algorithm

1. Define a `Pair(node, hd)` class to store node and its horizontal distance.
2. Initialize:

   * Queue `q = [Pair(root, 0)]`
   * Map `map = {}`
3. While queue not empty:

   * Pop front node `temp`
   * Set `map[temp.hd] = temp.node.data` (overwrite previous)
   * If left child exists → enqueue `Pair(left, hd-1)`
   * If right child exists → enqueue `Pair(right, hd+1)`
4. Sort map keys, push corresponding values to `ans`
5. Return `ans`

---

## Pseudocode

```
CLASS Pair:
    node
    hd

FUNCTION bottomView(root):
    IF root == NULL THEN RETURN []

    q = empty queue
    map = empty map
    ans = []

    ENQUEUE Pair(root, 0) INTO q

    WHILE q not empty:
        temp = DEQUEUE from q

        // Overwrite value at this horizontal distance
        map[temp.hd] = temp.node.data

        // Enqueue children with updated horizontal distances
        IF temp.node.left != NULL:
            ENQUEUE Pair(temp.node.left, temp.hd - 1)
        IF temp.node.right != NULL:
            ENQUEUE Pair(temp.node.right, temp.hd + 1)

    sortedKeys = SORT keys of map in ascending order
    FOR key IN sortedKeys:
        APPEND map[key] TO ans

    RETURN ans
```

**Commentary:**

* BFS ensures **nodes at deeper levels replace earlier nodes at same HD**.
* Sorting HDs ensures **left-to-right order** in final answer.
* Time complexity: **O(n log n)** (for sorting HDs), space complexity: **O(n)**

---

## Flowchart

```
           [Start: root node]
                  |
        [Is root null?]---Yes--->[Return []]
                  |
                  No
                  |
        [Enqueue Pair(root,0) into queue]
                  |
        [While queue not empty]
                  |
           [Dequeue node]
                  |
      [Set map[hd] = node.data] //overwrite previous
                  |
 [Enqueue left child with hd-1 if exists]
 [Enqueue right child with hd+1 if exists]
                  |
        [After BFS, sort map keys]
                  |
     [Append map values in sorted order to ans]
                  |
               [Return ans]
```

---

## Dry Run Example

Input tree:

```
        1
       / \
      2   3
       \   \
        4   5
```

**Step-by-step:**

1. Start: queue = `[Pair(1,0)]`, map = `{}`
2. Dequeue 1, HD=0 → map[0] = 1
3. Enqueue left: Pair(2,-1), right: Pair(3,1)
4. Dequeue 2, HD=-1 → map[-1] = 2
5. Left null, right: Pair(4,0) → queue = [Pair(3,1), Pair(4,0)]
6. Dequeue 3, HD=1 → map[1] = 3
7. Left null, right: Pair(5,2) → queue = [Pair(4,0), Pair(5,2)]
8. Dequeue 4, HD=0 → map[0] = 4 (overwrite)
9. Dequeue 5, HD=2 → map[2] = 5
10. Sort keys: [-1,0,1,2] → ans = [2,4,3,5]

**Output:** `[2,4,3,5]`

This confirms the **bottom view is correctly computed**.

---

