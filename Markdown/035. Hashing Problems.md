# **LeetCode 349: Intersection of Two Arrays**

**Code (unchanged):**

```javascript
var intersection = function(nums1, nums2) {
    let set1 = new Set(nums1)
    return [...new Set(nums2.filter(n => set1.has(n)))]
};
```

---

## **1. Problem Understanding**

* **Input:** Two integer arrays `nums1` and `nums2`.
* **Output:** An array of unique integers that are present in both arrays (intersection).
* **Important:** Each element should appear **only once** in the result.

**Example:**

```text
nums1 = [1,2,2,1], nums2 = [2,2] 
Output: [2]

nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]  (order doesn’t matter)
```

---

## **2. Rules / Approach**

1. Use a `Set` to store unique values from `nums1`.
2. For each element in `nums2`, check if it exists in the set.
3. Keep only unique elements in the output (using another `Set` or checking duplicates).
4. Convert the set back to an array for the result.

---

## **3. Step-by-Step Explanation**

1. Create a `Set` from `nums1` → this removes duplicates and allows fast lookup.
   Example: `[1,2,2,1]` → `Set {1,2}`
2. Filter elements in `nums2` that are present in `set1`.
   Example: `[2,2]` → check each `2` → it exists in `set1` → keep it.
3. Wrap the filtered array with `Set` → ensures only unique elements in the output.
4. Convert the set to array using `[...set]`.

**Flow:**

```text
nums1 -> Set -> {1,2}
nums2 -> Filter -> [2,2] -> Set -> {2} -> Array -> [2]
```

---

## **4. Pseudocode**

```
FUNCTION intersection(nums1, nums2)
    CREATE set1 FROM nums1
    result = EMPTY SET
    FOR each number n IN nums2
        IF n EXISTS IN set1
            ADD n TO result
    RETURN array CONVERTED FROM result
END FUNCTION
```

---

## **5. Flowchart Diagram**

```
[Start]
   |
   v
[Create set1 from nums1]
   |
   v
[For each n in nums2]
   |
   v
{Does set1 contain n?} --No--> [Next n]
        |
       Yes
        |
        v
   [Add n to result set]
        |
        v
[All nums2 processed?] --No--> [Next n]
        |
       Yes
        |
        v
[Convert result set to array]
        |
        v
[Return array]
        |
        v
       [End]
```

---

## **6. Examples**

```javascript
intersection([1,2,2,1], [2,2])  // Output: [2]
intersection([4,9,5], [9,4,9,8,4]) // Output: [9,4] or [4,9]
intersection([1,2,3], [4,5,6]) // Output: []
intersection([], [1,2,3])      // Output: []
```

---
---
---
---
---

# **LeetCode 349 II: Intersection of Two Arrays II**

**Code (unchanged):**

```javascript
var intersect = function(nums1, nums2) {
    if (nums1.length > nums2.length) [nums1, nums2] = [nums2, nums1];
    let freq = {};
    for (let i=0; i<nums1.length; i++) {
        let n = nums1[i]
        freq[n] = (freq[n] || 0) + 1;
    }

    let arr = [];
    for (let i=0; i<nums2.length; i++) {
        let n = nums2[i]
        if (freq[n] > 0) {
            arr.push(n);
            freq[n]--; 
        }
    }
    return arr;
};
```

---

## **1. Problem Understanding**

* **Input:** Two integer arrays `nums1` and `nums2`.
* **Output:** An array of integers that appear in both arrays, **including duplicates**.
* **Important:** Each element can appear in the result as many times as it shows in both arrays.

**Example:**

```text
nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]

nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9] or [9,4]
```

---

## **2. Rules / Approach**

1. Swap arrays to make sure `nums1` is smaller → reduces memory for frequency map.
2. Count frequency of each number in `nums1` using a hash map.
3. Iterate through `nums2`, if the number exists in the map with frequency > 0, add it to result and decrement frequency.
4. Return the result array.

---

## **3. Step-by-Step Explanation**

1. Compare lengths → swap if needed: ensures `nums1` is smaller (optimization).
2. Build frequency map of `nums1`:

   ```text
   nums1 = [1,2,2,1] => freq = {1:2, 2:2}
   ```
3. Initialize empty result array.
4. Loop through `nums2`:

   * If number exists in `freq` with count > 0 → push to result and decrease count.

   ```text
   nums2 = [2,2]
   2 exists in freq? yes (count 2) → push 2, freq[2] = 1
   next 2 → push 2, freq[2] = 0
   ```
5. Return result `[2,2]`.

---

## **4. Pseudocode**

```
FUNCTION intersect(nums1, nums2)
    IF length(nums1) > length(nums2)
        SWAP nums1 AND nums2
    CREATE empty freq_map
    FOR each n IN nums1
        freq_map[n] = freq_map[n] + 1 (default 0)
    CREATE empty result array
    FOR each n IN nums2
        IF freq_map[n] > 0
            ADD n TO result
            DECREMENT freq_map[n]
    RETURN result
END FUNCTION
```

---

## **5. Flowchart Diagram**

```
[Start]
   |
   v
[If nums1.length > nums2.length?] --Yes--> [Swap nums1 and nums2]
        |
       No
        |
        v
[Create freq_map for nums1]
        |
        v
[Initialize empty result array]
        |
        v
[For each n in nums2]
        |
{Is freq_map[n] > 0?} --No--> [Next n]
        |
       Yes
        |
        v
[Push n to result array]
[Decrement freq_map[n]]
        |
        v
[All nums2 processed?] --No--> [Next n]
        |
       Yes
        |
        v
[Return result array]
        |
        v
       [End]
```

---

## **6. Examples**

```javascript
intersect([1,2,2,1], [2,2])  // Output: [2,2]
intersect([4,9,5], [9,4,9,8,4]) // Output: [4,9] or [9,4]
intersect([1,2,3], [4,5,6]) // Output: []
intersect([1,2,2,3], [2,2,3,3]) // Output: [2,2,3]
```

---
---
---
---
---

# **LeetCode 560: Subarray Sum Equals K**

**Code (unchanged):**

```javascript
var subarraySum = function(nums, k) {
    let sum = 0, count = 0
    let map = new Map()
    map.set(0, 1);

    for (let i = 0; i < nums.length; i++) {
        sum += nums[i]

        if (map.has(sum - k)) {
            count += map.get(sum - k)
        }
        map.set(sum, (map.get(sum) || 0) + 1)
    }
    return count
};
```

---

## **1. Problem Understanding**

* **Input:** An integer array `nums` and an integer `k`.
* **Output:** Count of continuous subarrays whose sum equals `k`.
* **Important:** Subarrays are **contiguous sequences** of the array.

**Example:**

```text
nums = [1,1,1], k = 2
Output: 2  // [1,1] at positions [0,1] and [1,2]

nums = [1,2,3], k = 3
Output: 2  // [1,2] and [3]
```

---

## **2. Rules / Approach**

1. Use **prefix sum**: sum of elements from index 0 to i.
2. Use a **hash map** to store frequency of prefix sums.
3. For current prefix sum `sum`, check if `(sum - k)` exists in map → means there’s a subarray ending at current index with sum `k`.
4. Increment count by frequency of `(sum - k)` in the map.
5. Update map with current prefix sum frequency.

---

## **3. Step-by-Step Explanation**

1. Initialize `sum = 0`, `count = 0`, and `map = {0:1}`.
2. Loop through array `nums`:

   * Add `nums[i]` to `sum`.
   * Check if `(sum - k)` exists in `map`:

     * Yes → increment `count` by `map[sum - k]`.
   * Update `map[sum] = map[sum] + 1` (or set to 1 if not exists).
3. Return `count`.

**Example Trace:**

```text
nums = [1,2,3], k = 3
map = {0:1}, sum = 0, count = 0

i=0: sum = 1
sum-k = 1-3=-2 (not in map)
map = {0:1, 1:1}

i=1: sum = 3
sum-k = 3-3=0 (in map, value=1)
count = 0+1=1
map = {0:1,1:1,3:1}

i=2: sum = 6
sum-k = 6-3=3 (in map, value=1)
count = 1+1=2
map = {0:1,1:1,3:1,6:1}

Output: 2
```

---

## **4. Pseudocode**

```
FUNCTION subarraySum(nums, k)
    sum = 0
    count = 0
    map = {0:1}  // prefix sum frequency

    FOR i FROM 0 TO length(nums)-1
        sum += nums[i]
        IF (sum - k) EXISTS IN map
            count += map[sum - k]
        map[sum] = map.get(sum, 0) + 1
    RETURN count
END FUNCTION
```

---

## **5. Flowchart Diagram**

```
[Start]
   |
   v
[Initialize sum=0, count=0, map={0:1}]
   |
   v
[For each element in nums]
   |
   v
[sum = sum + nums[i]]
   |
   v
{Does map contain sum - k?} --No--> [Skip]
        |
       Yes
        |
        v
[count = count + map[sum - k]]
        |
        v
[Update map[sum] = map.get(sum,0)+1]
        |
        v
[All elements processed?] --No--> [Next element]
        |
       Yes
        |
        v
[Return count]
        |
        v
       [End]
```

---

## **6. Examples**

```javascript
subarraySum([1,1,1], 2)      // Output: 2
subarraySum([1,2,3], 3)      // Output: 2
subarraySum([1,2,1,2,1], 3)  // Output: 4 ([1,2],[2,1],[1,2],[2,1])
subarraySum([1, -1, 0], 0)   // Output: 3 ([1,-1],[ -1,0],[0])
```

---
---
---
---
---


# **GFG: Longest Subarray with Sum K**

**Code (unchanged):**

```javascript
var longestSubarray = function(arr, k) {
    let sum = 0, longest = 0
    let map = new Map()
    map.set(0, -1);

    for (let i = 0; i < arr.length; i++) {
        sum += arr[i]
        if (map.has(sum - k)) {
            longest = Math.max(longest, i - map.get(sum - k))
        }
        if (!map.has(sum)) {
            map.set(sum, i)
        }
    }
    return longest
}
```

---

## **1. Problem Understanding**

* **Input:** An integer array `arr` and an integer `k`.
* **Output:** Length of the **longest contiguous subarray** whose sum equals `k`.
* **Important:** Only the length is needed, not the actual subarray.

**Example:**

```text
arr = [1,2,3], k = 3
Output: 2  // Subarray [1,2] or [3]

arr = [1, -1, 5, -2, 3], k = 3
Output: 4  // Subarray [1, -1, 5, -2]
```

---

## **2. Rules / Approach**

1. Use **prefix sum**: sum of elements from index 0 to i.
2. Use a **hash map** to store the **first occurrence index** of each prefix sum.
3. For current prefix sum `sum`, check if `(sum - k)` exists in map → means a subarray ending at current index has sum `k`.
4. Update `longest` as `max(longest, i - map[sum-k])`.
5. Store the first occurrence of prefix sum in map if not already present.

---

## **3. Step-by-Step Explanation**

1. Initialize:

   * `sum = 0` → current prefix sum
   * `longest = 0` → max length found
   * `map = {0: -1}` → to handle subarray starting from index 0
2. Loop through array:

   * Add `arr[i]` to `sum`.
   * Check if `(sum - k)` exists in `map`:

     * Yes → update `longest = max(longest, i - map[sum-k])`.
   * If `sum` is not in map, store `sum` with current index `i`.
3. Return `longest`.

**Example Trace:**

```text
arr = [1, -1, 5, -2, 3], k = 3
map = {0:-1}, sum = 0, longest = 0

i=0: sum=1, sum-k=1-3=-2 (not in map), map={0:-1,1:0}
i=1: sum=0, sum-k=0-3=-3 (not in map), map already has 0, skip
i=2: sum=5, sum-k=5-3=2 (not in map), map={0:-1,1:0,5:2}
i=3: sum=3, sum-k=3-3=0 (exists at -1)
       longest = max(0,3-(-1))=4
       map={0:-1,1:0,5:2,3:3}
i=4: sum=6, sum-k=6-3=3 (exists at 3)
       longest=max(4,4-3)=4
map updated, done
Output: 4
```

---

## **4. Pseudocode**

```
FUNCTION longestSubarray(arr, k)
    sum = 0
    longest = 0
    map = {0: -1}  // prefix sum first occurrence

    FOR i FROM 0 TO length(arr)-1
        sum += arr[i]
        IF (sum - k) EXISTS IN map
            longest = MAX(longest, i - map[sum - k])
        IF sum NOT IN map
            map[sum] = i
    RETURN longest
END FUNCTION
```

---

## **5. Flowchart Diagram**

```
[Start]
   |
   v
[Initialize sum=0, longest=0, map={0:-1}]
   |
   v
[For each element in arr]
   |
   v
[sum = sum + arr[i]]
   |
   v
{Does map contain sum - k?} --No--> [Skip]
        |
       Yes
        |
        v
[longest = max(longest, i - map[sum-k])]
        |
        v
{Is sum already in map?} --Yes--> [Skip]
        |
       No
        |
        v
[map[sum] = i]
        |
        v
[All elements processed?] --No--> [Next element]
        |
       Yes
        |
        v
[Return longest]
        |
        v
       [End]
```

---

## **6. Examples**

```javascript
longestSubarray([1,2,3], 3)           // Output: 2 ([1,2])
longestSubarray([1,-1,5,-2,3], 3)     // Output: 4 ([1,-1,5,-2])
longestSubarray([1,2,1,2,1], 3)       // Output: 2 ([1,2] or [2,1])
longestSubarray([1,-1,0], 0)          // Output: 3 ([1,-1,0])
```

---