# Backtracking and How It Works in Stack

Backtracking is a general algorithmic technique that tries out different possibilities (choices), explores them recursively, and then **undoes (backtracks)** when a path doesn’t work or when the recursion finishes. It’s often used in problems like maze-solving, N-Queens, Sudoku, generating subsets, permutations, etc.

---

## 1. How Backtracking Works with the Call Stack

When you use recursion:

1. **Function Call → Push to Call Stack**

   * Each recursive call is added (pushed) to the call stack.
   * The state (local variables, parameters) of that function call is preserved separately.

2. **Explore → Make a Choice**

   * The function explores one possible path.
   * If a condition is met, recursion goes deeper.

3. **Base Case → Start Returning**

   * When recursion hits a base case, the function returns.
   * This is where "backtracking" begins.

4. **Backtracking Step → Undo Choice**

   * On returning, the last made choice is undone (clean up state).
   * Then the next possibility is tried.

5. **Pop from Stack**

   * After completing all possibilities in that call, it’s removed (popped) from the call stack.

---

## 2. Visual Flow (Stack Behavior Example)

Let’s take **printing all binary strings of length 2** as an example:

```js
function generateBinary(n, s = "") {
    if (n === 0) {
        console.log(s);
        return;
    }
    generateBinary(n - 1, s + "0");  // choice 1
    generateBinary(n - 1, s + "1");  // choice 2
}
```

Call trace for `generateBinary(2, "")`:

```
generateBinary(2,"")
 ├── generateBinary(1,"0")
 │     ├── generateBinary(0,"00") → print "00"
 │     └── generateBinary(0,"01") → print "01"
 └── generateBinary(1,"1")
       ├── generateBinary(0,"10") → print "10"
       └── generateBinary(0,"11") → print "11"
```

---

## 3. What Executes During **Backtracking**

* When a recursive call finishes, control returns to the previous stack frame.
* Any **statements after the recursive call** execute during backtracking.

Example:

```js
function backtrackExample(n) {
    if (n === 0) return;
    console.log("Before recursion: " + n);
    backtrackExample(n - 1);
    console.log("After recursion (backtracking): " + n);
}
backtrackExample(3);
```

**Output:**

```
Before recursion: 3
Before recursion: 2
Before recursion: 1
After recursion (backtracking): 1
After recursion (backtracking): 2
After recursion (backtracking): 3
```

Notice:

* **Forward path (recursive calls)** executes `Before recursion`.
* **Backtracking (returns)** executes `After recursion`.

---

## 4. Key Point

> Whatever you write **after** the recursive call inside the function will execute **during backtracking**.

That’s how algorithms like N-Queens "remove queens" after trying them, or subset generation "removes the last element" after exploring.

---