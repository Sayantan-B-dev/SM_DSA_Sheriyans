# 1. Valid Sudoku (LeetCode 36)

---

## Problem Understanding

* Given a **9x9 Sudoku board**, check if it is **valid**.
* Rules:

  1. Each **row** must contain unique numbers 1–9.
  2. Each **column** must contain unique numbers 1–9.
  3. Each **3x3 sub-box** must contain unique numbers 1–9.
* Empty cells are denoted by `"."` and can be ignored.

---

## Approach

* Use **recursion with backtracking** (though this is mostly checking, not solving).

* Track seen numbers using **three sets/maps**:

  1. `rows` → Set for each row.
  2. `cols` → Set for each column.
  3. `squares` → Set for each 3x3 sub-grid, keyed by `(rowIndex//3)-(colIndex//3)`.

* For each cell `(i,j)`:

  1. Skip if it contains `"."`.
  2. Calculate `s_key = floor(i/3) + '-' + floor(j/3)` for the 3x3 square.
  3. If number exists in `rows[i]`, `cols[j]`, or `squares[s_key]`, return `false`.
  4. Otherwise, add number to all three sets.
  5. Recurse to next cell `(i,j+1)`; if `j==9`, move to next row `(i+1,0)`.

* If all cells are valid, return `true`.

---

## Algorithm

1. Initialize maps for rows, columns, and squares:

   * `rows[i]` = new Set()
   * `cols[j]` = new Set()
   * `squares[s_key]` = new Set()
2. Recursive function `checkCell(i,j)`:

   * If `i == 9`, return `true`.
   * If `j == 9`, return `checkCell(i+1, 0)`.
   * If `board[i][j] !== "."`:

     * Compute `s_key = floor(i/3) + '-' + floor(j/3)`.
     * If number exists in row, col, or square → return `false`.
     * Else, add number to row, col, square.
   * Recurse `checkCell(i,j+1)`.
3. Call `checkCell(0,0)`.
4. Return result.

---

## Pseudocode

```
FUNCTION isValidSudoku(board):
    rows, cols, squares = maps of sets
    INITIALIZE rows, cols for 0..8
    INITIALIZE squares for keys "0-0" to "2-2"

    FUNCTION checkCell(i, j):
        IF i == 9: RETURN true
        IF j == 9: RETURN checkCell(i+1, 0)
        n = board[i][j]
        IF n != ".":
            s_key = floor(i/3) + "-" + floor(j/3)
            IF n in rows[i] OR cols[j] OR squares[s_key]:
                RETURN false
            ADD n to rows[i], cols[j], squares[s_key]
        RETURN checkCell(i, j+1)

    RETURN checkCell(0,0)
```

---

## Dry Run Example

Board snippet (partial):

```
[
 ["5","3",".",".","7",".",".",".","."],
 ["6",".",".","1","9","5",".",".","."],
 ...
]
```

```
i=0, j=0, n=5
  s_key = "0-0"
  rows[0] = {}, cols[0] = {}, squares["0-0"] = {}
  Add 5 to rows[0], cols[0], squares["0-0"]

i=0, j=1, n=3
  s_key = "0-0"
  Add 3 to rows[0], cols[1], squares["0-0"]

i=0, j=2, n="." -> skip

...
i=1, j=0, n=6
  s_key = "0-0"
  Add 6 to rows[1], cols[0], squares["0-0"]

...
Check continues for all cells
No duplicates found → return true
```

---

# 2. Sudoku Solver (LeetCode 37)

---

## Problem Understanding

* Given a **partially filled 9x9 Sudoku board**, fill in the empty cells so that:

  1. Each **row** contains numbers 1–9 exactly once.
  2. Each **column** contains numbers 1–9 exactly once.
  3. Each **3x3 sub-box** contains numbers 1–9 exactly once.
* Empty cells are denoted by `"."`.
* The board **must be modified in-place** to produce a valid solution.

---

## Approach

* Use **backtracking / DFS**:

  1. **Track numbers** already used in:

     * `rows[i]` → Set of numbers used in row `i`.
     * `cols[j]` → Set of numbers used in column `j`.
     * `squares[k]` → Set of numbers used in 3x3 square `k`.

       * `k = Math.floor(i/3) * 3 + Math.floor(j/3)` to map `(i,j)` to 0–8.
  2. **Identify empty cells** in advance and store in `emptyCells` array to only iterate over blanks.
  3. Recursive function `solve(index)`:

     * Base case: If `index == emptyCells.length`, return `true` → solution found.
     * Get coordinates `[i,j] = emptyCells[index]`.
     * Try numbers `1–9`:

       * If number is **not present** in `rows[i]`, `cols[j]`, `squares[k]`:

         * Place number on board.
         * Add to all sets.
         * Recurse `solve(index + 1)`.
         * If recursion succeeds → return true.
         * Else → **backtrack**: remove number from board and sets.
     * If no number works → return false.
  4. Start recursion at `solve(0)`.

---

## Algorithm

1. Initialize `rows`, `cols`, `squares` as arrays of sets.
2. Initialize `emptyCells = []`.
3. Populate `rows`, `cols`, `squares` with existing numbers on the board.
4. Populate `emptyCells` with coordinates of `"."`.
5. Recursive function `solve(index)`:

   * Base case: `index == emptyCells.length` → return true.
   * `[i,j] = emptyCells[index]`, `s_key = boxIndex(i,j)`.
   * Loop `n = 1..9`:

     * If `n` not in `rows[i]`, `cols[j]`, `squares[s_key]`:

       * Place `n` on board.
       * Add `n` to sets.
       * Recurse `solve(index+1)`.
       * If false → backtrack.
   * Return false if no valid number.
6. Call `solve(0)`.
7. Return modified board.

---

## Pseudocode

```
FUNCTION solveSudoku(board):
    rows, cols, squares = arrays of sets
    emptyCells = []

    FUNCTION boxIndex(i,j):
        RETURN floor(i/3)*3 + floor(j/3)

    FOR i in 0..8:
        FOR j in 0..8:
            IF board[i][j] == ".":
                emptyCells.push([i,j])
            ELSE:
                n = board[i][j]
                rows[i].add(n)
                cols[j].add(n)
                squares[boxIndex(i,j)].add(n)

    FUNCTION solve(index):
        IF index == length(emptyCells): RETURN true
        [i,j] = emptyCells[index]
        s_key = boxIndex(i,j)
        FOR n = 1..9:
            ch = str(n)
            IF ch not in rows[i], cols[j], squares[s_key]:
                board[i][j] = ch
                rows[i].add(ch)
                cols[j].add(ch)
                squares[s_key].add(ch)
                IF solve(index+1): RETURN true
                // backtrack
                board[i][j] = "."
                rows[i].remove(ch)
                cols[j].remove(ch)
                squares[s_key].remove(ch)
        RETURN false

    CALL solve(0)
    RETURN board
```

---

## Flow of Execution

1. Scan the board once → populate sets and `emptyCells`.
2. Start filling numbers at first empty cell.
3. At each cell:

   * Try `1..9`.
   * Check **row, column, square constraints**.
   * If valid → place number, move to next empty cell.
   * If stuck → backtrack to previous cell and try next number.
4. Continue until all empty cells are filled.

---

## Dry Run Example

Board (partial):

```
[["5","3",".",".","7",".",".",".","."],
 ["6",".",".","1","9","5",".",".","."],
 [".","9","8",".",".",".",".","6","."],
 ...]
```

1. `emptyCells = [[0,2],[0,3],[0,5],...]`
2. `solve(0)` → cell [0,2]:

   * Try 1 → valid? yes → place 1
   * Recurse `solve(1)` → next empty cell [0,3]
   * Try numbers until a valid solution is found.
3. Backtracking occurs if a number leads to dead-end later.
4. Once `solve(index == emptyCells.length)` → board is solved.

---

## Key Points

* **Backtracking** ensures exploration of all possibilities.
* Using **sets** allows **O(1) checking** for valid numbers.
* Pre-storing empty cells **reduces redundant scanning**.
* The solution **modifies board in-place**.

---

# 3. N-Queens (LeetCode 51)

---

## Problem Understanding

* Place `n` queens on an `n x n` chessboard such that **no two queens attack each other**.

* Rules:

  1. No two queens can be in the **same row**.
  2. No two queens can be in the **same column**.
  3. No two queens can be on the **same diagonal**.

* Goal: Return **all valid board configurations**.

---

## Approach

* Use **backtracking** with **sets** to track conflicts:

  1. **`col`** → columns that already have a queen.
  2. **`posDiagonal`** → r+c (positive slope) conflicts.
  3. **`negDiagonal`** → r-c (negative slope) conflicts.
* Recursively place queens **row by row**:

  1. For row `i`, try each column `j`.
  2. Skip if column or diagonal conflicts exist.
  3. Place queen:

     * Mark `col`, `posDiagonal`, `negDiagonal`.
     * Update `board[i][j] = "Q"`.
  4. Recurse to next row `i+1`.
  5. Backtrack:

     * Remove queen from sets and board.
* Base case: If `i == n`, copy current board and add to results.

---

## Algorithm

1. Initialize:

   * `col = Set()`, `posDiagonal = Set()`, `negDiagonal = Set()`.
   * `board = n x n` grid filled with `"."`.
   * `res = []` to store valid boards.
2. Recursive function `solve(i)`:

   * If `i == n`, push a copy of `board` rows as joined strings to `res` and return.
   * Loop `j = 0..n-1`:

     * If `j` in `col` or `i+j` in `posDiagonal` or `i-j` in `negDiagonal` → continue.
     * Add `j` to `col`, `i+j` to `posDiagonal`, `i-j` to `negDiagonal`.
     * Place queen on `board[i][j] = "Q"`.
     * Recurse `solve(i+1)`.
     * Backtrack:

       * Remove marks from sets.
       * Reset `board[i][j] = "."`.
3. Call `solve(0)`.
4. Return `res`.

---

## Pseudocode

```
FUNCTION solveNQueens(n):
    col = Set()
    posDiagonal = Set()
    negDiagonal = Set()
    board = n x n grid of "."
    res = []

    FUNCTION solve(i):
        IF i == n:
            res.push(copy of board rows joined as strings)
            RETURN
        FOR j in 0..n-1:
            IF j in col OR i+j in posDiagonal OR i-j in negDiagonal:
                CONTINUE
            col.add(j)
            posDiagonal.add(i+j)
            negDiagonal.add(i-j)
            board[i][j] = "Q"
            solve(i+1)
            col.delete(j)
            posDiagonal.delete(i+j)
            negDiagonal.delete(i-j)
            board[i][j] = "."
    
    solve(0)
    RETURN res
```

---

## Flow of Execution

1. Start at row 0, try all columns.
2. For each valid placement:

   * Mark conflicts.
   * Move to next row recursively.
3. Repeat until all rows are filled → save board.
4. Backtrack to explore other column placements.
5. Continue until all combinations are explored.

---

## Dry Run Example (n = 4)

```
board initially: 4x4 all "."

Row 0:
- Place Q at (0,0) -> mark col=0, posDiagonal=0, negDiagonal=0
Row 1:
- Try col=0 -> conflict with col -> skip
- Try col=1 -> conflict with posDiagonal (1+1=2) ? check -> okay
- ...
Continue recursively
Backtrack as necessary

Final solutions:
[
 [".Q..",
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",
  "Q...",
  "...Q",
  ".Q.."]
]
```
---

# 4. Word Search (LeetCode 79)

---

## Problem Understanding

* Given a **2D board of letters** and a **word**, determine if the word exists in the board.
* Rules:

  1. Word can be constructed from **letters of sequentially adjacent cells** (horizontal or vertical).
  2. **Same cell cannot be used more than once**.

**Example:**

```
board = [
 ["A","B","C","E"],
 ["S","F","C","S"],
 ["A","D","E","E"]
]
word = "ABCCED" → true
```

---

## Approach

* Use **DFS with backtracking**:

  1. Traverse each cell `(r, c)` in the board.
  2. Start DFS from `(r, c)` if `board[r][c] == word[0]`.
  3. Recursive DFS:

     * Base case: if `i == word.length` → all letters matched → return true.
     * Boundary and mismatch check:

       * `r<0 || c<0 || r>=rows || c>=cols || board[r][c] != word[i]` → return false.
     * Temporarily mark current cell as visited (e.g., `board[r][c] = "#"`) to avoid reuse.
     * Recurse in **4 directions**: up, down, left, right with `i+1`.
     * Restore the cell after DFS (backtracking).
  4. If any DFS returns true → word exists.
  5. If all starting points fail → word does not exist.

---

## Algorithm

1. Get `row = board.length`, `col = board[0].length`.
2. Define recursive `dfs(r, c, i)`:

   * If `i == word.length` → return true.
   * If out-of-bounds or mismatch → return false.
   * Save current letter `temp = board[r][c]`.
   * Mark `board[r][c] = "#"`.
   * `res = dfs(r+1,c,i+1) || dfs(r-1,c,i+1) || dfs(r,c+1,i+1) || dfs(r,c-1,i+1)`.
   * Restore `board[r][c] = temp`.
   * Return `res`.
3. Iterate over all board cells `(i,j)`:

   * If `dfs(i,j,0)` → return true.
4. Return false.

---

## Pseudocode

```
FUNCTION exist(board, word):
    row = length(board)
    col = length(board[0])

    FUNCTION dfs(r, c, i):
        IF i == length(word): RETURN true
        IF r<0 OR c<0 OR r>=row OR c>=col OR board[r][c] != word[i]: RETURN false
        temp = board[r][c]
        board[r][c] = "#"
        res = dfs(r+1,c,i+1) OR dfs(r-1,c,i+1) OR dfs(r,c+1,i+1) OR dfs(r,c-1,i+1)
        board[r][c] = temp
        RETURN res

    FOR i in 0..row-1:
        FOR j in 0..col-1:
            IF dfs(i,j,0): RETURN true
    RETURN false
```

---

## Flow of Execution

1. Start from each cell as potential first letter.
2. For each match, explore all **adjacent cells recursively**.
3. Mark visited cells to prevent revisiting.
4. If DFS reaches end of word → return true.
5. Backtrack after exploring each path to restore board for other paths.
6. If no path matches → return false.

---

## Dry Run Example

Board:

```
[
 ["A","B","C","E"],
 ["S","F","C","S"],
 ["A","D","E","E"]
]
word = "ABCCED"
```

* Start DFS at (0,0) = "A":

  * Match "B" at (0,1)

    * Match "C" at (0,2)

      * Match "C" at (1,2)

        * Match "E" at (2,2)

          * Match "D" at (2,1) → word complete → return true
* DFS stops as solution found.
