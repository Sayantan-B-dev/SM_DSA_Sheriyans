# LeetCode 82: Remove Duplicates from Sorted List II

## Problem Scenario

Given the head of a **sorted linked list**, remove all nodes that have **duplicate numbers**, leaving only distinct numbers from the original list. Return the linked list **sorted as well**.

**Example:**
Input: `1 → 2 → 3 → 3 → 4 → 4 → 5`
Output: `1 → 2 → 5`

Input: `1 → 1 → 1 → 2 → 3`
Output: `2 → 3`

---

## Algorithm

1. Create a **dummy node** pointing to head (handles edge cases where head itself is a duplicate).
2. Maintain a **prev pointer** pointing to the node before the current sequence.
3. Traverse the list with a **temp pointer**:

   * If `temp.val === temp.next.val`, it indicates duplicates.

     * Move `temp` forward until all duplicates are skipped.
     * Link `prev.next` to `temp.next` to remove duplicates.
   * Else, move `prev` to `prev.next`.
4. Continue until the end of the list.
5. Return `dummy.next`.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

## Pseudocode

```
function deleteDuplicates(head):
    if head is null:
        return null

    dummy = new Node(0)
    dummy.next = head
    prev = dummy
    temp = head

    while temp is not null:
        if temp.next is not null AND temp.val == temp.next.val:
            while temp.next is not null AND temp.val == temp.next.val:
                temp = temp.next
            prev.next = temp.next
        else:
            prev = prev.next
        temp = temp.next

    return dummy.next
```

---

## Flowchart

```
Start
  |
  v
Check if head is null → Yes → Return null
  |
  No
  v
Create dummy node → dummy.next = head
prev = dummy
temp = head
  |
  v
While temp != null
  |
  v
Check if temp.next != null AND temp.val == temp.next.val
  |                 \
Yes                  No
  |                   \
  v                    prev = prev.next
Skip duplicates:        \
While temp.next != null AND temp.val == temp.next.val:
    temp = temp.next      \
prev.next = temp.next      \
  |                        \
temp = temp.next             \
  |                         /
  v
End of list → Return dummy.next
```

---

## Well-Visualized Example

**Input:** `1 → 2 → 3 → 3 → 4 → 4 → 5`

1. Create dummy: `0 → 1 → 2 → 3 → 3 → 4 → 4 → 5`
2. temp = 1 → no duplicates → move prev → prev = 1
3. temp = 2 → no duplicates → move prev → prev = 2
4. temp = 3 → duplicate detected

   * Skip all 3s → temp = 3 (second) → temp = 4
   * Link prev.next = 4 → list: `0 → 1 → 2 → 4 → 4 → 5`
5. temp = 4 → duplicate detected

   * Skip all 4s → temp = 4 (second) → temp = 5
   * Link prev.next = 5 → list: `0 → 1 → 2 → 5`
6. temp = 5 → no duplicates → move prev → prev = 5
7. End of list → return `dummy.next = 1 → 2 → 5`

---

## Key Points

* Using a **dummy node** avoids special handling for head duplicates.
* Inner while loop **skips all duplicate nodes**.
* Maintains **O(1) extra space** and **linear time**.

# LeetCode 160: Intersection of Two Linked Lists

## Problem Scenario

Given two singly linked lists, find the node at which the two lists **intersect**. If they do not intersect, return `null`.

**Example:**
List A: `4 → 1 → 8 → 4 → 5`
List B: `5 → 0 → 1 → 8 → 4 → 5`
Output: Node with value `8`

---

## Algorithm (Without Caring About Space Complexity)

1. Traverse List A and store all nodes in a **set**.
2. Traverse List B and for each node, check if it exists in the set.
3. First node found in the set is the **intersection node**.
4. If no node matches, return `null`.

**Time Complexity:** O(m + n)
**Space Complexity:** O(m)

---

## Algorithm (Optimized for O(1) Space)

1. Use two pointers `t1` and `t2` starting at headA and headB.
2. Move both pointers one step at a time.
3. When a pointer reaches the end of its list, redirect it to the head of the other list.
4. Eventually, they will meet at the intersection node or both become `null` if no intersection exists.

**Time Complexity:** O(m + n)
**Space Complexity:** O(1)

---

## Pseudocode

**Using Extra Space:**

```
function getIntersectionNode(headA, headB):
    if headA is null or headB is null:
        return null

    set = empty set
    tempA = headA
    while tempA != null:
        add tempA to set
        tempA = tempA.next

    tempB = headB
    while tempB != null:
        if tempB in set:
            return tempB
        tempB = tempB.next

    return null
```

**Optimized (O(1) Space):**

```
function getIntersectionNode(headA, headB):
    if headA is null or headB is null:
        return null

    t1 = headA
    t2 = headB

    while t1 != t2:
        t1 = t1.next if t1 != null else headB
        t2 = t2.next if t2 != null else headA

    return t1
```

---

## Flowchart (Optimized Version)

```
Start
  |
  v
Check if headA or headB is null → Yes → Return null
  |
  No
  v
t1 = headA, t2 = headB
  |
  v
While t1 != t2
  |
  v
t1 = (t1 != null) ? t1.next : headB
t2 = (t2 != null) ? t2.next : headA
  |
  v
End loop → Return t1 (intersection node or null)
```

---

## Well-Visualized Example

**List A:** `4 → 1 → 8 → 4 → 5`
**List B:** `5 → 0 → 1 → 8 → 4 → 5`

1. Initialize t1 = 4 (A), t2 = 5 (B)
2. Move pointers:

   * t1: 1 → 8 → 4 → 5 → null → switch to headB → 5 → 0 → 1 → 8
   * t2: 0 → 1 → 8 → 4 → 5 → null → switch to headA → 4 → 1 → 8
3. Pointers meet at node with value 8 → **intersection found**

**Key Points:**

* Switching heads ensures both pointers traverse **same total length**.
* Handles lists of **different lengths** efficiently.
* Optimized approach requires **no extra memory**.

# LeetCode 142: Linked List Cycle II

## Problem Scenario

Given the head of a linked list, **detect if a cycle exists** and return the node where the cycle begins. If there is no cycle, return `null`.

**Example:**
Input: `3 → 2 → 0 → -4` with tail connecting to node `2`
Output: Node with value `2`

---

## Algorithm (Floyd’s Tortoise and Hare)

1. Use **two pointers**: `slow` moves one step, `fast` moves two steps.
2. Detect cycle: if `slow === fast` at any point, cycle exists.
3. To find the **start of the cycle**:

   * Initialize `p1` at head and `p2` at meeting point (`slow`).
   * Move both one step at a time until `p1 === p2`.
   * That node is the **cycle start**.
4. If `fast` reaches `null`, there is **no cycle**.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

## Pseudocode

```
function detectCycle(head):
    if head is null OR head.next is null:
        return null

    slow = head
    fast = head

    while fast != null AND fast.next != null:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            p1 = head
            p2 = slow
            while p1 != p2:
                p1 = p1.next
                p2 = p2.next
            return p1

    return null
```

---

## Flowchart

```
Start
  |
  v
Check if head is null or head.next is null → Yes → Return null
  |
  No
  v
slow = head, fast = head
  |
  v
While fast != null AND fast.next != null
  |
  v
slow = slow.next
fast = fast.next.next
  |
  v
Check if slow == fast → Yes → cycle detected
  |                       \
  No                        Initialize p1=head, p2=slow
  |                       \
Loop continues              |
                            v
While p1 != p2:
    p1 = p1.next
    p2 = p2.next
  |
  v
Return p1 (cycle start)
  |
  v
No cycle → Return null
```

---

## Well-Visualized Example

**Input:** `3 → 2 → 0 → -4` (cycle starts at node 2)

1. Initialize: slow = 3, fast = 3
2. Move pointers:

   * slow = 2, fast = 0
   * slow = 0, fast = 2
   * slow = -4, fast = -4 → **cycle detected**
3. Initialize p1 = head (3), p2 = meeting point (-4)
4. Move both pointers one step:

   * p1 = 3 → 2, p2 = -4 → 2
5. p1 == p2 → **cycle starts at node 2**

**Key Points:**

* Floyd’s algorithm ensures **O(n) time** and **O(1) space**.
* The distance from head to cycle start equals the distance from meeting point to cycle start along the cycle.
* Avoids extra data structures like sets or maps.

# LeetCode 203: Remove Linked List Elements

## Problem Scenario

Given the head of a linked list and a value `val`, **remove all nodes** that have the value `val` and return the new head.

**Example:**
Input: `1 → 2 → 6 → 3 → 4 → 5 → 6`, `val = 6`
Output: `1 → 2 → 3 → 4 → 5`

---

## Algorithm

1. **Handle head nodes**: While the head is not null and `head.val === val`, move head forward.
2. Initialize a **temp pointer** to traverse the list.
3. While `temp.next` is not null:

   * If `temp.next.val === val`, skip the node by `temp.next = temp.next.next`.
   * Else, move `temp` forward.
4. Return the updated `head`.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

## Pseudocode

```
function removeElements(head, val):
    while head != null AND head.val == val:
        head = head.next

    temp = head
    while temp != null AND temp.next != null:
        if temp.next.val == val:
            temp.next = temp.next.next
        else:
            temp = temp.next

    return head
```

---

## Flowchart

```
Start
  |
  v
While head != null AND head.val == val:
    head = head.next
  |
  v
temp = head
  |
  v
While temp != null AND temp.next != null:
    if temp.next.val == val:
        temp.next = temp.next.next
    else:
        temp = temp.next
  |
  v
Return head
```

---

## Well-Visualized Example

**Input:** `1 → 2 → 6 → 3 → 4 → 5 → 6`, `val = 6`

1. Head node = 1 → not 6 → move forward
2. temp = 1 → temp.next = 2 → not 6 → move temp
3. temp = 2 → temp.next = 6 → match → skip node → link 2 → 3
4. temp = 3 → temp.next = 4 → not 6 → move temp
5. temp = 4 → temp.next = 5 → not 6 → move temp
6. temp = 5 → temp.next = 6 → match → skip node → link 5 → null
7. End → Return head: `1 → 2 → 3 → 4 → 5`

**Key Points:**

* Continuously update head if initial nodes match the value.
* Inner loop skips matching nodes efficiently.
* Works in **O(n) time** without extra space.

# LeetCode 237: Delete Node in a Linked List

## Problem Scenario

You are given **only access to a node** in a singly linked list (not the head) and asked to delete that node. You **cannot access the previous node**.

**Example:**
Input: `4 → 5 → 1 → 9`, node = `5`
Output: `4 → 1 → 9`

---

## Algorithm

1. Copy the **value of the next node** into the current node.
2. Skip the next node by updating `node.next = node.next.next`.
3. Effectively, the node to be "deleted" now contains the next node’s value and bypasses it.

**Time Complexity:** O(1)
**Space Complexity:** O(1)

---

## Pseudocode

```
function deleteNode(node):
    node.val = node.next.val
    node.next = node.next.next
```

---

## Flowchart

```
Start
  |
  v
Copy value from next node: node.val = node.next.val
  |
  v
Skip next node: node.next = node.next.next
  |
  v
End
```

---

## Well-Visualized Example

**Original List:** `4 → 5 → 1 → 9`, node = 5

1. Copy next value: `node.val = node.next.val` → node becomes 1 → list: `4 → 1 → 1 → 9`
2. Skip next node: `node.next = node.next.next` → list: `4 → 1 → 9`

**Key Points:**

* Only works if the node is **not the tail**.
* No need to traverse the list or find the previous node.
* Simple **O(1) solution** using value overwrite and pointer update.

# LeetCode 234: Palindrome Linked List

## Problem Scenario

Given the head of a singly linked list, determine if it is a **palindrome** (reads the same forwards and backwards).

**Example:**
Input: `1 → 2 → 2 → 1`
Output: `true`

Input: `1 → 2`
Output: `false`

---

## Algorithm 1: O(n) Space (Using Array)

1. Traverse the list and store values in an array.
2. Use two pointers (`i = 0`, `j = arr.length - 1`) to compare values.
3. If all corresponding values match, it is a palindrome.
4. Otherwise, return `false`.

**Time Complexity:** O(n)
**Space Complexity:** O(n)

---

## Algorithm 2: O(1) Space (Optimized)

1. Find the middle of the linked list using **fast and slow pointers**.
2. Reverse the second half of the list.
3. Compare the first half and the reversed second half node by node.
4. Restore the list (optional) by reversing the second half again.
5. Return `true` if all nodes match, else `false`.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

## Pseudocode (O(1) Space)

```
function reverseList(head):
    prev = null
    curr = head
    while curr != null:
        nextTemp = curr.next
        curr.next = prev
        prev = curr
        curr = nextTemp
    return prev

function isPalindrome(head):
    if head == null OR head.next == null:
        return true

    slow = head
    fast = head

    while fast.next != null AND fast.next.next != null:
        slow = slow.next
        fast = fast.next.next

    secondHalf = reverseList(slow.next)
    first = head
    second = secondHalf

    while second != null:
        if first.val != second.val:
            return false
        first = first.next
        second = second.next

    slow.next = reverseList(secondHalf)  // optional restore
    return true
```

---

## Flowchart (O(1) Space)

```
Start
  |
  v
Check if head is null or head.next is null → Yes → Return true
  |
  No
  v
Find middle using slow & fast pointers
  |
  v
Reverse second half of the list
  |
  v
Compare first half and reversed second half
  |
  v
If mismatch → Return false
Else → Restore list (optional)
  |
  v
Return true
```

---

## Well-Visualized Example

**Input:** `1 → 2 → 2 → 1`

1. Find middle: slow = 2 (first 2), fast = 1 (last)
2. Reverse second half: `2 → 1` becomes `1 → 2`
3. Compare halves:

   * first = 1, second = 1 → match
   * first = 2, second = 2 → match
4. No mismatch → palindrome → return `true`
5. Restore list: `1 → 2 → 2 → 1` (optional)

**Key Points:**

* Reversing second half allows **O(1) space comparison**.
* Fast & slow pointer method efficiently finds the middle.
* Two approaches: **space trade-off vs in-place modification**.

