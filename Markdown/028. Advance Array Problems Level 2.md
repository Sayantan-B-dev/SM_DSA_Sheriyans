## ğŸ”‘ Rules of Kadaneâ€™s Algorithm

1. **Keep a running sum** (`currentSum`):

   * Add each element to `currentSum`.
   * If `currentSum` becomes negative, reset it to 0 (because any negative prefix will only hurt future sums).

2. **Track the maximum sum so far** (`maxSum`):

   * Update `maxSum` whenever `currentSum` is larger.

3. **Result**:

   * At the end, `maxSum` holds the maximum subarray sum.

---

## âœ… Pseudocode

```
currentSum = 0
maxSum = -âˆ

for each num in nums:
    currentSum = currentSum + num
    if currentSum > maxSum:
        maxSum = currentSum
    if currentSum < 0:
        currentSum = 0

return maxSum
```

---

## âš¡ Example Walkthrough

Array: `[âˆ’2,1,âˆ’3,4,âˆ’1,2,1,âˆ’5,4]`

* Start: `currentSum=0`, `maxSum=-âˆ`
* num = âˆ’2 â†’ currentSum = âˆ’2 â†’ reset to 0, maxSum = âˆ’2
* num = 1 â†’ currentSum = 1 â†’ maxSum = 1
* num = âˆ’3 â†’ currentSum = âˆ’2 â†’ reset to 0
* num = 4 â†’ currentSum = 4 â†’ maxSum = 4
* num = âˆ’1 â†’ currentSum = 3 â†’ maxSum = 4
* num = 2 â†’ currentSum = 5 â†’ maxSum = 5
* num = 1 â†’ currentSum = 6 â†’ maxSum = 6
* num = âˆ’5 â†’ currentSum = 1 â†’ maxSum = 6
* num = 4 â†’ currentSum = 5 â†’ maxSum = 6

Result = `6` (subarray `[4,âˆ’1,2,1]`).

---

## ğŸŸ¢ Optimized JS Implementation

```js
var maxSubArray = function(nums) {
    let currentSum = 0;
    let maxSum = nums[0]; // important for all-negative arrays

    for (let num of nums) {
        currentSum += num;
        if (currentSum > maxSum) maxSum = currentSum;
        if (currentSum < 0) currentSum = 0;
    }
    return maxSum;
};
```

---

## ğŸ“Š Complexity

* **Time**: O(n)
* **Space**: O(1)

---

## ğŸ”‘ Problem it solves

Find the **majority element** in an array (the element that appears more than âŒŠn/2âŒ‹ times).

* LeetCode 169: *Majority Element*

---

## âš¡ Rules of Boyerâ€“Mooreâ€™s Algorithm

1. **Keep a candidate (`ans`) and a counter (`count`).**

   * Initially `count = 0`.

2. **Iterate through the array:**

   * If `count === 0`, pick the current number as the new candidate (`ans = num`, `count = 1`).
   * Else if `num === ans`, increment `count`.
   * Else decrement `count`.

3. **Return `ans` at the end.**

   * Guaranteed to be the majority element if one exists (> âŒŠn/2âŒ‹).

---

## âœ… Pseudocode

```
ans = 0
count = 0

for num in nums:
    if count == 0:
        ans = num
        count = 1
    else if num == ans:
        count++
    else:
        count--

return ans
```

---

## ğŸ” Example

Input: `[6, 5, 5]`

* Start: `ans = 0, count = 0`
* num = 6 â†’ count=0 â‡’ ans=6, count=1
* num = 5 â†’ numâ‰ ans â‡’ count=0
* num = 5 â†’ count=0 â‡’ ans=5, count=1

Result â†’ `5`

---

## ğŸŸ¢ Optimized JS Code

```js
var majorityElement = function(nums) {
    let ans = 0, count = 0;

    for (const num of nums) {
        if (count === 0) {
            ans = num;
            count = 1;
        } else if (num === ans) {
            count++;
        } else {
            count--;
        }
    }
    return ans;
};
```

---

## ğŸ“Š Complexity

* **Time:** O(n) â†’ single pass
* **Space:** O(1) â†’ constant memory

---

âš¡ Fun fact: The "voting" name comes from the idea that every element â€œvotesâ€ for itself, and non-majority votes cancel each other out â€” leaving the majority as the final survivor.

---

![](../images/28/1.png)
![](../images/28/2.png)
![](../images/28/3.png)