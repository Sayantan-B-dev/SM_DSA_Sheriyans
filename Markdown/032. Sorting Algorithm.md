# Cycle Sort — complete guide

Nice choice — Cycle Sort is special: **it’s in-place and does the minimum possible number of writes** (useful when writes are expensive). But it costs in comparisons: **O(n²)**. Below you'll find the algorithm, clean pseudocode, a JavaScript implementation (handles duplicates), a careful step-by-step execution example, uses, and complexity analysis.

---

# 1) Short idea / intuition

* Each element belongs to a unique *correct position* (its rank among the remaining elements).
* For each index `cycle_start`, place the correct element into that index by rotating a cycle of elements — put the item where it belongs, pick up the displaced item, put that where it belongs, etc., until the cycle closes.
* Important: initialize `pos = cycle_start` and compute `pos += 1` for every element to the right that is **less than** `item`. That gives the final index for `item` among the remaining slots.

This method minimizes writes because each element is written at most once to its correct place (so total writes ≤ n).

---

# 2) Pseudocode

```
for cycle_start from 0 to n-2:
    item = arr[cycle_start]
    pos = cycle_start
    // find position where item should go
    for i from cycle_start+1 to n-1:
        if arr[i] < item:
            pos = pos + 1

    // if item is already at correct position, continue
    if pos == cycle_start:
        continue

    // skip duplicates: if arr[pos] == item, move pos forward
    while item == arr[pos]:
        pos = pos + 1

    // put item to its right position
    swap(item, arr[pos])

    // continue rotating the rest of the cycle until we return to start
    while pos != cycle_start:
        pos = cycle_start
        for i from cycle_start+1 to n-1:
            if arr[i] < item:
                pos = pos + 1
        while item == arr[pos]:
            pos = pos + 1
        swap(item, arr[pos])
```

Notes:

* `swap(item, arr[pos])` means: place `item` into `arr[pos]` and set `item` to the old `arr[pos]` (i.e., `temp = arr[pos]; arr[pos] = item; item = temp;`).
* The `while item == arr[pos] pos++` step is how duplicates are handled — we skip positions already holding that same value.

---

# 3) JavaScript implementation (handles duplicates)

```js
function cycleSort(arr) {
    const n = arr.length;
    let writes = 0; // optional: count actual writes

    for (let cycleStart = 0; cycleStart <= n - 2; cycleStart++) {
        let item = arr[cycleStart];

        // Find position where we put the item
        let pos = cycleStart;
        for (let i = cycleStart + 1; i < n; i++) {
            if (arr[i] < item) pos++;
        }

        // If item already in correct position, continue
        if (pos === cycleStart) continue;

        // Skip duplicates
        while (item === arr[pos]) pos++;

        // Put the item to its right position
        if (pos !== cycleStart) {
            const temp = arr[pos];
            arr[pos] = item;
            item = temp;
            writes++;
        }

        // Rotate rest of the cycle
        while (pos !== cycleStart) {
            pos = cycleStart;
            for (let i = cycleStart + 1; i < n; i++) {
                if (arr[i] < item) pos++;
            }
            while (item === arr[pos]) pos++;

            const temp = arr[pos];
            arr[pos] = item;
            item = temp;
            writes++;
        }
    }

    return { sorted: arr, writes }; // returns sorted array and write-count
}
```

---

# 4) Step-by-step execution example

Use array: `[3, 5, 2, 1, 4]`

We’ll show the important steps (cycle starts, `item`, computed `pos`, swap action, and array after swap).

Initial: `arr = [3, 5, 2, 1, 4]` (n = 5)

### cycleStart = 0

* `item = arr[0] = 3`
* Compute pos (start pos = 0):

  * i=1: arr[1]=5 < 3? no → pos=0
  * i=2: arr[2]=2 < 3? yes → pos=1
  * i=3: arr[3]=1 < 3? yes → pos=2
  * i=4: arr[4]=4 < 3? no → pos stays 2
* pos = 2 → not equal to cycleStart(0)
* `arr[2]` is 2, not equal to item 3 → swap: place `3` at index 2, `item` becomes `2`

  * After swap: `arr = [3, 5, 3, 1, 4]`, `item = 2`
* pos != cycleStart, continue rotating the cycle:

  * Recompute pos for `item = 2` (pos starts 0):

    * i=1: arr[1]=5 < 2? no
    * i=2: arr[2]=3 < 2? no
    * i=3: arr[3]=1 < 2? yes → pos = 1
    * i=4: arr[4]=4 < 2? no → pos = 1
  * pos = 1, arr[1] = 5 != item 2 → swap: put `2` at index 1, `item` becomes `5`

    * After swap: `arr = [3, 2, 3, 1, 4]`, `item = 5`
  * Recompute pos for `item = 5`:

    * i=1..4: values less than 5 are 2,3,1,4 → pos becomes 4
  * pos = 4, arr[4] = 4 != 5 → swap: put `5` at index 4, `item` becomes `4`

    * After swap: `arr = [3, 2, 3, 1, 5]`, `item = 4`
  * Recompute pos for `item = 4`:

    * elements < 4 (indices 1..4) are 2,3,1 → pos = 3
  * pos = 3, arr[3] = 1 != 4 → swap: put `4` at index 3, `item` becomes `1`

    * After swap: `arr = [3, 2, 3, 4, 5]`, `item = 1`
  * Recompute pos for `item = 1`:

    * None of the elements to the right are < 1 → pos = 0
  * pos = 0, arr[0] = 3 != 1 → swap: put `1` at index 0, `item` becomes `3`

    * After swap: `arr = [1, 2, 3, 4, 5]`, `item = 3`
  * Now pos == cycleStart (0) → cycle done.

Array after cycleStart=0: `[1, 2, 3, 4, 5]`

### cycleStart = 1, 2, 3...

* For the rest of cycleStart values, each `item` is already at correct position, so no more swaps. The algorithm ends with sorted array `[1, 2, 3, 4, 5]`.

**Total writes** in this example = number of times we assigned into `arr[pos]` during swaps — much less than number of comparisons.

---

# 5) Use cases / when to choose Cycle Sort

* **When writes are expensive** (flash memory, EEPROM, or any medium with limited write cycles). Cycle sort minimizes writes (each element is written at most once to its final position).
* **When you must sort in-place** and minimize memory usage. It uses O(1) extra space.
* **When the cost of reading/comparing is cheap relative to writing**.
* Not suitable when you need a *stable* sort (Cycle Sort is **not stable**).
* Not ideal for large datasets where comparison cost dominates — other O(n log n) sorts (QuickSort, MergeSort, TimSort) are usually faster overall.

---

# 6) Time & space complexity

* **Time (comparisons):** Worst / Average / Best — **O(n²)** (because for each cycle you scan the remaining elements to compute `pos`).
* **Number of writes (array assignments):** **O(n)** (minimal possible writes to generate sorted order).
* **Space:** **O(1)** extra space (in-place), plus O(1) loop variables. The output is the array itself.
* **Stability:** **Not stable**.
* **Adaptive:** Not adaptive — performance does not improve on partially sorted input (still O(n²) comparisons).

---

# 7) Practical tips & pitfalls

* Always set `pos = cycleStart` and only compare elements after `cycleStart` to compute `pos`. This avoids double-counting while the array mutates.
* Use `while (item == arr[pos]) pos++` to handle duplicates (skip identical values).
* If you cannot modify the input array (must preserve original), you must copy it first — that ruins the O(1) space advantage.
* Because of O(n²) comparisons, cycle sort is rarely used for large general-purpose sorting — it's a niche algorithm for write-sensitive contexts.

---

# 8) Small demo run (JS) — try it

```js
let a = [3,5,2,1,4];
console.log(cycleSort(a)); // { sorted: [1,2,3,4,5], writes: <small number> }
```
