# ðŸŸ¢ 1. Operations with **Set**

A **Set** in JavaScript is a collection of **unique values**. No duplicates allowed.

| Operation       | Description                 | Example                            |
| --------------- | --------------------------- | ---------------------------------- |
| `new Set()`     | Creates a new set           | `let s = new Set();`               |
| `add(value)`    | Adds a value                | `s.add(10);`                       |
| `delete(value)` | Removes a value             | `s.delete(10);`                    |
| `has(value)`    | Checks existence            | `s.has(10) // true/false`          |
| `size`          | Returns number of elements  | `s.size`                           |
| `clear()`       | Removes all values          | `s.clear();`                       |
| Iteration       | Use `for...of` or `forEach` | `for (let v of s) console.log(v);` |

ðŸ‘‰ **Why Set is important in interviews?**

* Used to **remove duplicates**.
* Helps in problems requiring **fast existence check**.
* Common in **cycle detection** (e.g., Happy Number).

---

# ðŸŸ¢ 2. Happy Number Problem Using Set

**Definition**: A number is *happy* if repeatedly replacing it with the sum of squares of its digits eventually reaches `1`.
If it falls into a cycle (never reaching 1), itâ€™s not happy.

ðŸ‘‰ **Why Set here?**

* Set detects cycles. If the same number appears again â†’ infinite loop â†’ not happy.

### Example:

```js
function isHappy(n) {
  let seen = new Set();

  while (n !== 1 && !seen.has(n)) {
    seen.add(n);
    n = sumOfSquares(n);
  }

  return n === 1;
}

function sumOfSquares(num) {
  return num.toString()
            .split('')
            .reduce((sum, d) => sum + d * d, 0);
}

console.log(isHappy(19)); // true
console.log(isHappy(20)); // false
```

âœ… **Interview Logic**:

* Use **Set** to avoid infinite loop.
* Time complexity: `O(log n)` (digits reduce fast).
* Space complexity: `O(log n)` for storing visited numbers.

---

# ðŸŸ¢ 3. Operations with **Map**

A **Map** stores keyâ€“value pairs. Unlike objects, keys can be any type (number, string, object, etc.).

| Operation         | Description                  | Example                               |
| ----------------- | ---------------------------- | ------------------------------------- |
| `new Map()`       | Creates a new map            | `let m = new Map();`                  |
| `set(key, value)` | Add/update entry             | `m.set("a", 10)`                      |
| `get(key)`        | Get value                    | `m.get("a") // 10`                    |
| `has(key)`        | Check key existence          | `m.has("a")`                          |
| `delete(key)`     | Remove key-value             | `m.delete("a")`                       |
| `clear()`         | Remove all entries           | `m.clear();`                          |
| `keys()`          | Returns iterator of keys     | `for (let k of m.keys())`             |
| `values()`        | Returns iterator of values   | `for (let v of m.values())`           |
| `entries()`       | Returns `[key, value]` pairs | `for (let [k,v] of m.entries())`      |
| Iteration         | `forEach((v,k)=>{})`         | `m.forEach((v,k)=> console.log(k,v))` |

---

# ðŸŸ¢ 4. Importance of **Keys in Map**

* **Objects** â†’ keys are always **strings** (or symbols).
* **Map** â†’ keys can be **any data type** (string, number, object, function).

ðŸ‘‰ Example:

```js
let m = new Map();
let objKey = {id: 1};
m.set(objKey, "User 1");

console.log(m.get(objKey)); // "User 1"
```

* Here `objKey` works as a **reference key**, which isnâ€™t possible in plain objects.
* In interviews â†’ Mention that **Maps preserve insertion order** and are optimized for frequent additions/removals.

---

# ðŸŸ¢ 5. Use Map for Frequency Counting

**Problem**: Count how many times each element appears in an array.

ðŸ‘‰ **Logic**:

* Traverse array.
* For each element â†’ `map.set(element, (map.get(element) || 0) + 1)`.

### Example:

```js
function frequencyCount(arr) {
  let freq = new Map();

  for (let num of arr) {
    freq.set(num, (freq.get(num) || 0) + 1);
  }

  return freq;
}

let arr = [1, 2, 2, 3, 3, 3, 4];
let result = frequencyCount(arr);

for (let [num, count] of result.entries()) {
  console.log(num, "appears", count, "times");
}
```

âœ… Output:

```
1 appears 1 times
2 appears 2 times
3 appears 3 times
4 appears 1 times
```

# ðŸŸ¢ 1. How to find the element with **maximum frequency**?

ðŸ‘‰ **Logic**:

* Build frequency map.
* Track element with the highest frequency while iterating.

```js
function maxFrequency(arr) {
  let freq = new Map();

  for (let num of arr) {
    freq.set(num, (freq.get(num) || 0) + 1);
  }

  let maxCount = 0, maxElem = null;
  for (let [num, count] of freq.entries()) {
    if (count > maxCount) {
      maxCount = count;
      maxElem = num;
    }
  }

  return { element: maxElem, frequency: maxCount };
}

console.log(maxFrequency([1,2,2,3,3,3,4]));
```

âœ… Output:

```
{ element: 3, frequency: 3 }
```

ðŸ“Œ **Interview Point**:

* Time complexity: `O(n)`.
* Space complexity: `O(n)` (for the Map).

---

# ðŸŸ¢ 2. How to remove duplicates from an array using **Map**?

ðŸ‘‰ **Logic**:

* When first seen â†’ store in map.
* Ignore if already present.

```js
function removeDuplicates(arr) {
  let map = new Map();
  let result = [];

  for (let num of arr) {
    if (!map.has(num)) {
      map.set(num, true);
      result.push(num);
    }
  }

  return result;
}

console.log(removeDuplicates([1,2,2,3,3,4,5,5]));
```

âœ… Output:

```
[1, 2, 3, 4, 5]
```

ðŸ“Œ Note: In practice, `new Set(arr)` is simpler, but showing the **Map way** is interview-smart (demonstrates flexibility).

---

# ðŸŸ¢ 3. Difference between **Map vs Object** for frequency

ðŸ‘‰ This is **very common in interviews**. Letâ€™s put it in a chart:

| Feature         | **Map**                                                                  | **Object**                                                |
| --------------- | ------------------------------------------------------------------------ | --------------------------------------------------------- |
| Key type        | Any (number, string, object, function, etc.)                             | Only string or symbol (numbers auto-convert to string)    |
| Insertion order | Preserved                                                                | Not guaranteed (modern JS preserves but historically not) |
| Performance     | Optimized for frequent additions/removals                                | Slightly slower when handling large, dynamic data         |
| Size property   | `map.size` (direct)                                                      | `Object.keys(obj).length` (extra step)                    |
| Iteration       | Direct with `map.keys()`, `map.values()`, `map.entries()`                | Need `for...in` or `Object.keys/values/entries()`         |
| Use case        | Best for dynamic collections, frequency counting, caching, lookup tables | Best for structured data with fixed keys                  |

ðŸ‘‰ **Conclusion for interviews**:

* **Map** is preferred when keys are dynamic or not just strings (frequency counting, caching).
* **Object** is okay for structured, fixed data models (like representing a person: `{name: "X", age: 20}`).

---

