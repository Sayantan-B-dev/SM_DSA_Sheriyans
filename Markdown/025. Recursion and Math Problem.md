# Best Approach to Solve Any Recursion Problem

Solving recursion problems effectively requires a **structured approach**. Here’s a step-by-step methodology:

---

### 1. **Understand the Problem Clearly**

* Know exactly what the function needs to compute.
* Identify the **input and expected output**.
* Check for **edge cases** (empty input, zero, negative numbers, etc.).

---

### 2. **Identify the Base Case(s)**

* The base case stops recursion; without it, you get **infinite recursion**.
* Ask: “When can I solve this problem **directly** without recursion?”
* Example:

  * Factorial: `n == 0 → return 1`
  * Fibonacci: `n == 0 → return 0`, `n == 1 → return 1`

---

### 3. **Define the Recursive Case**

* Express the problem in terms of **smaller subproblems**.
* Think: “How can I reduce the problem size so it eventually reaches the base case?”
* Example:

  * Sum of array: `sum(arr) = arr[0] + sum(arr.slice(1))`
  * Power function: `n^p = n * n^(p-1)` or `n^p = (n^(p/2))^2`

---

### 4. **Choose Parameters Carefully**

* Decide which values need to be passed in recursive calls.
* Consider using **helper functions** if you need extra parameters (like accumulators) without exposing them to the main API.

---

### 5. **Think About the Return Value**

* Make sure each recursive call contributes correctly to the **final result**.
* Example:

  * Fibonacci: `return fib(n-1) + fib(n-2)`
  * Reverse digits: `return (n%10) + reverseDigits(Math.floor(n/10)) * 10^...`

---

### 6. **Consider Edge Cases**

* Negative numbers, zeros, empty arrays, single-element arrays.
* Avoid mistakes like division by zero or accessing out-of-bounds indexes.

---

### 7. **Optimize if Needed**

* **Memoization / Caching** for overlapping subproblems (e.g., Fibonacci).
* **Tail recursion / accumulators** to reduce stack usage.
* Avoid unnecessary repeated computations.

---

### 8. **Trace with Small Inputs**

* Manually trace the recursion for small examples.
* Draw a **call stack diagram** to ensure each step works correctly and returns as expected.

---

### 9. **Convert to Iterative if Large Inputs**

* If recursion depth may exceed stack limits, try **iterative approach** with loops or stacks.
* Sometimes recursion is cleaner, but iteration is safer for very large inputs.

---

### 10. **Test Thoroughly**

* Test with edge cases and normal cases.
* Confirm correctness and performance.

---

### Quick Checklist:

1. Understand the problem.
2. Identify base case(s).
3. Express problem recursively.
4. Decide parameters and return values.
5. Handle edge cases.
6. Optimize if necessary.
7. Trace small examples.
8. Convert to iterative if needed.
9. Test thoroughly.

---

This method works for **any recursion problem**, from arrays to strings to mathematical problems.

---

---

---

---

---
# Using Helper Functions in Recursion

Helper functions are a common pattern in recursion, especially when the main function has **limited parameters** or when you need **extra variables for recursion** (accumulators, indexes, state).

---

## 1. Why Use Helper Functions

* Sometimes the **main API function** must take only specific inputs.

  * Example: `sumOfDigits(n)` should only take `n`.
* But recursion may require **additional information**:

  * Current index in an array
  * Accumulated result
  * Partial state

Instead of exposing extra parameters to the user, a **helper function** keeps them internal.

---

## 2. Structure of Helper Functions

```js
function mainFunction(param1, param2) {
    function helper(param1, param2, extraParam) {
        if (base case) return result;

        // recursive call
        return helper(updatedParam1, updatedParam2, updatedExtra);
    }

    // Call helper with initial extra parameter
    return helper(param1, param2, initialExtra);
}
```

---

## 3. Examples

### Example 1: Sum of Digits with Accumulator

```js
function sumOfDigits(n) {
    function helper(num, acc) {
        if (num === 0) return acc;
        return helper(Math.floor(num / 10), acc + (num % 10));
    }

    return helper(n, 0);  // start accumulator at 0
}

console.log(sumOfDigits(1234)); // 10
```

* **Main function** takes only `n`.
* **Helper function** manages recursion and accumulation.

---

### Example 2: Reverse Digits

```js
function reverseDigits(n) {
    const sign = n < 0 ? -1 : 1;
    n = Math.abs(n);

    function helper(num, rev) {
        if (num === 0) return rev;
        return helper(Math.floor(num / 10), rev * 10 + (num % 10));
    }

    return sign * helper(n, 0);
}

console.log(reverseDigits(-123)); // -321
```

* **Helper keeps `rev` accumulator** hidden.
* User doesn’t need to pass `rev`.

---

### 4. Benefits of Helper Functions

1. **Cleaner API:** Users don’t see internal parameters.
2. **Supports Tail Recursion / Accumulators:**

   * Can make recursion efficient.
3. **Keeps State Local:**

   * Avoids global variables.
4. **Flexible:**

   * Can pass indexes, previous results, or other state needed for recursion.

---

### 5. General Pattern

```js
function mainFunction(userParam1, userParam2) {
    function helper(internalState1, internalState2) {
        if (base case) return value;

        // recursive call
        return helper(updatedState1, updatedState2);
    }

    return helper(initialState1, initialState2);
}
```

---

Helper functions are especially useful when you want to:

* Use **accumulators** (sum, product, reversed number).
* Track **current index or position** in arrays/strings.
* Maintain **intermediate states** without exposing them to the caller.

---
---
---
---
---
# Different Ways to Compute GCD

The **Greatest Common Divisor (GCD)** of two numbers is the largest positive integer that divides both numbers. There are several approaches to compute it.

---

## 1. **Using Modulo (Euclidean Algorithm)**

### Logic:

* If `b == 0`, GCD is `a`.
* Otherwise, `gcd(a, b) = gcd(b, a % b)`.

### Recursive Implementation:

```js
function gcd(a, b) {
    if (b === 0) return a;
    return gcd(b, a % b);
}
```

### Iterative Implementation:

```js
function gcd(a, b) {
    while (b !== 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

**Time Complexity:** O(log(min(a, b)))
**Most efficient in practice.**

---

## 2. **Using Repeated Subtraction**

### Logic:

* Subtract the smaller number from the larger until both numbers are equal.
* That value is the GCD.

### Recursive Implementation:

```js
function gcd(a, b) {
    if (a === b) return a;
    if (a > b) return gcd(a - b, b);
    else return gcd(a, b - a);
}
```

### Iterative Implementation:

```js
function gcd(a, b) {
    while (a !== b) {
        if (a > b) a -= b;
        else b -= a;
    }
    return a;
}
```

**Time Complexity:** O(max(a, b)) → less efficient than modulo method.

---

## 3. **Using Comparison and Decrementing (Naive Method)**

### Logic:

* Start from `min(a, b)` and check descending if it divides both `a` and `b`.
* The first number that divides both is the GCD.

### Implementation:

```js
function gcd(a, b) {
    let min = Math.min(a, b);
    for (let i = min; i >= 1; i--) {
        if (a % i === 0 && b % i === 0) return i;
    }
}
```

**Time Complexity:** O(min(a, b)) → slow for large numbers.

---

## 4. **Using Binary GCD (Stein’s Algorithm)**

### Logic:

* Use bitwise operations instead of modulo or subtraction:

  * If both even: `gcd(a, b) = 2 * gcd(a/2, b/2)`
  * If one even, one odd: divide the even number by 2
  * If both odd: subtract the smaller from the larger and continue

### Efficient for large integers (avoids division/modulo).

---

### Summary of Methods

| Method               | Approach           | Complexity      | Notes                       |
| -------------------- | ------------------ | --------------- | --------------------------- |
| Modulo (Euclidean)   | a % b              | O(log min(a,b)) | Most commonly used          |
| Repeated Subtraction | a - b              | O(max(a,b))     | Simple, slower              |
| Naive Comparison     | Check all divisors | O(min(a,b))     | Very slow for large numbers |
| Binary GCD (Stein)   | Bitwise operations | O(log min(a,b)) | Fastest for big integers    |

---