# Leetcode 98: Validate Binary Search Tree (BST)

## Problem Overview

Given a binary tree, determine if it is a **valid BST**.

**BST properties to check:**

1. Left subtree nodes < current node
2. Right subtree nodes > current node
3. Both subtrees are also valid BSTs

---

## Approach

### 1. Recursive Approach (Using Min/Max Constraint)

* Every node must lie within a valid **range**: `(min, max)`
* Initially, the root has range `(-∞, ∞)`
* For left child: `(min, parent.val)`
* For right child: `(parent.val, max)`
* If node violates the range → not a BST

### 2. Inorder Traversal Approach

* BST inorder traversal produces **strictly increasing sequence**
* Traverse the tree inorder, track previous value
* If current ≤ previous → not a BST

---

## Algorithm / Pseudocode (Min/Max Approach)

```
FUNCTION isValidBST(node, min, max):
    IF node == NULL: RETURN true
    IF node.val <= min OR node.val >= max: RETURN false
    RETURN isValidBST(node.left, min, node.val) AND
           isValidBST(node.right, node.val, max)
```

**Initial Call:**

```
isValidBST(root, -∞, ∞)
```

---

## Dry Run Example

Tree:

```
    2
   / \
  1   3
```

1. Root 2 → range (-∞, ∞) → valid
2. Left child 1 → range (-∞, 2) → valid
3. Right child 3 → range (2, ∞) → valid
4. Both children valid → tree is BST ✅

---

Tree:

```
    5
   / \
  1   4
     / \
    3   6
```

* Root 5 → (-∞, ∞) → valid
* Right child 4 → range (5, ∞) → 4 ≤ 5 → invalid ❌

---

## Dry Run Notes

* Each node is checked **against constraints from all ancestors**, not just immediate parent.
* Ensures **global BST property**, not local only.

---

## Code (Recursive, Min/Max)

```javascript
var isValidBST = function(root) {
    function validate(node, min, max){
        if(node === null) return true;
        if(node.val <= min || node.val >= max) return false;
        return validate(node.left, min, node.val) && 
               validate(node.right, node.val, max);
    }
    return validate(root, -Infinity, Infinity);
};
```

---

## Complexity Analysis

* **Time Complexity:** O(n) → each node visited once
* **Space Complexity:** O(h) → recursion stack (h = height of tree)

---

# Leetcode 230: Kth Smallest Element in a BST

## Problem Overview

Given a **BST** and an integer `k`, return the **kth smallest element** in the BST.

**Key Observations:**

1. Inorder traversal of a BST produces nodes in **ascending order**.
2. Therefore, the **kth element in inorder traversal** is the answer.

---

## Approach

### 1. Recursive Inorder Traversal

* Perform **inorder traversal**
* Keep a **counter**
* When counter == k → return the node value

### 2. Iterative Inorder Traversal

* Use a **stack** to simulate recursion
* Pop nodes in **ascending order**
* Count nodes until `k` is reached → return value

### 3. Optimized (BST with Node Counts)

* If BST nodes store **left subtree size**, can move directly to kth node
* More advanced, O(h) time

---

## Algorithm / Pseudocode (Recursive)

```
FUNCTION inorder(node):
    IF node == NULL: RETURN
    inorder(node.left)
    counter += 1
    IF counter == k:
        result = node.val
        RETURN
    inorder(node.right)

CALL inorder(root)
RETURN result
```

---

## Dry Run Example

BST:

```
        3
       / \
      1   4
       \
        2
```

`k = 1` → smallest element

* Inorder traversal → [1,2,3,4]
* Counter = 1 → result = 1

`k = 3` → third smallest

* Counter 1 → 1
* Counter 2 → 2
* Counter 3 → 3 → result = 3 ✅

---

## Code (Recursive)

```javascript
var kthSmallest = function(root, k) {
    let count = 0, result = null;

    function inorder(node){
        if(!node || result !== null) return;

        inorder(node.left);
        count++;
        if(count === k){
            result = node.val;
            return;
        }
        inorder(node.right);
    }

    inorder(root);
    return result;
};
```

---

## Code (Iterative)

```javascript
var kthSmallest = function(root, k) {
    let stack = [], current = root;

    while(current || stack.length){
        while(current){
            stack.push(current);
            current = current.left;
        }
        current = stack.pop();
        k--;
        if(k === 0) return current.val;
        current = current.right;
    }
};
```

---

## Complexity Analysis

* **Time Complexity:** O(h + k)

  * `h` = height of BST (traverse down to leftmost)
* **Space Complexity:** O(h)

  * Recursion stack or iterative stack

This leverages **inorder traversal** to efficiently find the kth smallest element in a BST.

---

# Leetcode 450: Delete Node in a BST

## Problem Overview

Given a **BST** and a value `key`, delete the node with that value and **return the new root**.

**BST Properties to Maintain:**

1. Left subtree < node < right subtree
2. BST structure after deletion is valid

---

## Approach

### Cases for Deletion

1. **Node not found** → return null
2. **Node is a leaf** → remove directly
3. **Node has one child** → replace node with its child
4. **Node has two children** → replace node with **inorder successor** (smallest node in right subtree) or **inorder predecessor** (largest in left subtree), then delete the successor/predecessor

### Steps:

* Find node recursively
* Handle deletion based on number of children
* Return the updated subtree root

---

## Algorithm / Pseudocode

```
FUNCTION deleteNode(root, key):
    IF root == NULL: RETURN NULL

    IF key < root.val:
        root.left = deleteNode(root.left, key)
    ELSE IF key > root.val:
        root.right = deleteNode(root.right, key)
    ELSE:
        // Node found
        IF root.left == NULL: RETURN root.right
        ELSE IF root.right == NULL: RETURN root.left
        ELSE:
            successor = findMin(root.right)
            root.val = successor.val
            root.right = deleteNode(root.right, successor.val)
    RETURN root

FUNCTION findMin(node):
    WHILE node.left != NULL:
        node = node.left
    RETURN node
```

---

## Dry Run Example

BST:

```
        5
       / \
      3   6
     / \   \
    2   4   7
```

**Delete 3:**

1. Node 3 has two children → find inorder successor → 4
2. Replace 3 with 4
3. Delete node 4 from right subtree of 3
   Result:

```
        5
       / \
      4   6
     /     \
    2       7
```

---

## Code (JavaScript)

```javascript
var deleteNode = function(root, key) {
    if(root === null) return null;

    if(key < root.val){
        root.left = deleteNode(root.left, key);
    } else if(key > root.val){
        root.right = deleteNode(root.right, key);
    } else {
        // Node found
        if(root.left === null) return root.right;
        else if(root.right === null) return root.left;
        else {
            let successor = findMin(root.right);
            root.val = successor.val;
            root.right = deleteNode(root.right, successor.val);
        }
    }
    return root;
};

function findMin(node){
    while(node.left !== null) node = node.left;
    return node;
}
```

---

## Complexity Analysis

* **Time Complexity:** O(h) → height of BST (search + deletion)
* **Space Complexity:** O(h) → recursion stack

This handles all cases and maintains BST property after deletion.

---

# Leetcode 235: Lowest Common Ancestor of a BST

## Problem Overview

Given a **BST** and two nodes `p` and `q`, find their **lowest common ancestor (LCA)**.

**BST Property to Leverage:**

* Left subtree < node < right subtree
* Right subtree > node > left subtree

---

## Approach

### Observations

1. If both `p` and `q` < current node → LCA is in **left subtree**
2. If both `p` and `q` > current node → LCA is in **right subtree**
3. Otherwise, **current node is LCA**

### Steps

* Start at root
* Compare root.val with `p.val` and `q.val`
* Move left or right accordingly
* Stop when root splits p and q

---

## Algorithm / Pseudocode

```
FUNCTION lowestCommonAncestor(root, p, q):
    IF root == NULL: RETURN NULL

    IF p.val < root.val AND q.val < root.val:
        RETURN lowestCommonAncestor(root.left, p, q)
    ELSE IF p.val > root.val AND q.val > root.val:
        RETURN lowestCommonAncestor(root.right, p, q)
    ELSE:
        RETURN root
```

---

## Dry Run Example

BST:

```
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5
```

* `p = 2`, `q = 8`

  * Root 6 → p < 6, q > 6 → split → LCA = 6

* `p = 2`, `q = 4`

  * Root 6 → p < 6, q < 6 → go left to 2
  * Root 2 → p = 2, q = 4 → split → LCA = 2

---

## Code (JavaScript)

```javascript
var lowestCommonAncestor = function(root, p, q) {
    if(!root) return null;

    if(p.val < root.val && q.val < root.val){
        return lowestCommonAncestor(root.left, p, q);
    } else if(p.val > root.val && q.val > root.val){
        return lowestCommonAncestor(root.right, p, q);
    } else {
        return root;
    }
};
```

---

## Complexity Analysis

* **Time Complexity:** O(h) → height of BST (search path)
* **Space Complexity:** O(h) → recursion stack

This efficiently finds the LCA using **BST ordering**, no need to traverse entire tree.

---

# Leetcode 700: Search in a Binary Search Tree (BST)

## Problem Overview

Given a **BST** and a value `val`, return the **subtree rooted at the node with that value**, or `null` if it doesn’t exist.

**BST Property:**

* Left subtree < node < right subtree
* Right subtree > node > left subtree

---

## Approach

### 1. Recursive Search

* If node is `null` → return `null`
* If `node.val == val` → return node
* If `val < node.val` → search left subtree
* If `val > node.val` → search right subtree

### 2. Iterative Search

* Start at root
* Traverse left or right based on comparison
* Stop when node.val == val or node == null

---

## Algorithm / Pseudocode

```
FUNCTION searchBST(node, val):
    WHILE node != NULL:
        IF node.val == val:
            RETURN node
        ELSE IF val < node.val:
            node = node.left
        ELSE:
            node = node.right
    RETURN NULL
```

---

## Dry Run Example

BST:

```
        4
       / \
      2   7
     / \
    1   3
```

* `val = 2`

  * Root 4 → 2 < 4 → go left
  * Node 2 → 2 == 2 → return node (subtree rooted at 2)

* `val = 5`

  * Root 4 → 5 > 4 → go right
  * Node 7 → 5 < 7 → go left
  * Node null → return null

---

## Code (Iterative)

```javascript
var searchBST = function(root, val) {
    let node = root;
    while(node) {
        if(node.val === val) return node;
        else if(val < node.val) node = node.left;
        else node = node.right;
    }
    return null;
};
```

---

## Code (Recursive)

```javascript
var searchBST = function(root, val) {
    if(!root) return null;
    if(root.val === val) return root;
    return val < root.val ? searchBST(root.left, val) : searchBST(root.right, val);
};
```

---

## Complexity Analysis

* **Time Complexity:** O(h) → height of BST (best O(log n) for balanced, worst O(n) for skewed)
* **Space Complexity:**

  * Iterative → O(1)
  * Recursive → O(h) due to recursion stack

This efficiently finds the subtree rooted at a given value in a BST.
