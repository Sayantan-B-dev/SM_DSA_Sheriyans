# 🟢 1. **Two Sum Problem**

**Problem**: Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

---

### 🔹 Approach 1: Brute Force

* For every pair `(i, j)`, check if `nums[i] + nums[j] == target`.
* Return the indices if found.

```js
function twoSumBrute(nums, target) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
}
```

⏱️ Time: `O(n²)`
📦 Space: `O(1)`
👉 Simple but slow for large arrays.

---

### 🔹 Approach 2: Hash Map (Efficient)

* Store numbers in a hash map while iterating.
* For each `num`, check if `target - num` exists in map.
* If yes → found the pair.

```js
function twoSum(nums, target) {
    let map = new Map();
    for (let i = 0; i < nums.length; i++) {
        let complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        map.set(nums[i], i);
    }
}
```

⏱️ Time: `O(n)`
📦 Space: `O(n)`
👉 Very efficient, widely expected in interviews.

---

# 🟢 2. **LeetCode 2351: First Letter to Appear Twice**

**Problem**: Given a string `s`, return the first character that appears twice.

---

### 🔹 Approach 1: Brute Force

* For each character, check the rest of the string to see if it appears again.
* Return the first one that repeats.

```js
function firstRepeatedBrute(s) {
    for (let i = 0; i < s.length; i++) {
        for (let j = i + 1; j < s.length; j++) {
            if (s[i] === s[j]) return s[i];
        }
    }
}
```

⏱️ Time: `O(n²)`
📦 Space: `O(1)`

---

### 🔹 Approach 2: Hash Set (Efficient)

* Keep a `Set` of seen characters.
* If we encounter a character already in `Set`, return it immediately.

```js
function firstRepeated(s) {
    let seen = new Set();
    for (let ch of s) {
        if (seen.has(ch)) return ch;
        seen.add(ch);
    }
}
```

⏱️ Time: `O(n)`
📦 Space: `O(n)`
👉 Fast and concise.

---

# 🟢 3. **LeetCode 2418: Sort the People**

**Problem**: Given arrays `names` and `heights`, return the names sorted in descending order by height.

---

### 🔹 Approach 1: Brute Force (Selection Sort style)

* Pair names with heights in an array of objects.
* Use nested loops to sort manually.

```js
function sortPeopleBrute(names, heights) {
    let arr = names.map((name, i) => [name, heights[i]]);
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j][1] > arr[i][1]) {
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }
    }
    return arr.map(([name]) => name);
}
```

⏱️ Time: `O(n²)`
📦 Space: `O(n)`

---

### 🔹 Approach 2: Built-in Sort (Efficient)

* Pair names and heights.
* Use `.sort()` with comparator based on heights.

```js
function sortPeople(names, heights) {
    return names
        .map((name, i) => [name, heights[i]])
        .sort((a, b) => b[1] - a[1])
        .map(([name]) => name);
}
```

⏱️ Time: `O(n log n)`
📦 Space: `O(n)`
👉 Expected in interviews, clean and efficient.

---

# 🟢 1. Number System Conversions

### 🔹 A. Decimal → Binary

**Method:** Divide repeatedly by 2, record remainders, read upwards.
**Example:** Convert `25` to binary.

* 25 ÷ 2 = 12 remainder **1**
* 12 ÷ 2 = 6 remainder **0**
* 6 ÷ 2 = 3 remainder **0**
* 3 ÷ 2 = 1 remainder **1**
* 1 ÷ 2 = 0 remainder **1**

👉 Binary = `11001`

---

### 🔹 B. Binary → Decimal

**Method:** Multiply each bit by power of 2, add up.
**Example:** `11001` = ?
\= 1×2⁴ + 1×2³ + 0×2² + 0×2¹ + 1×2⁰
\= 16 + 8 + 0 + 0 + 1 = **25**

---

### 🔹 C. Decimal → Octal

**Method:** Divide repeatedly by 8.
**Example:** 83 → ?

* 83 ÷ 8 = 10 remainder **3**
* 10 ÷ 8 = 1 remainder **2**
* 1 ÷ 8 = 0 remainder **1**
  👉 Octal = `123`

---

### 🔹 D. Decimal → Hexadecimal

**Method:** Divide repeatedly by 16. Digits above 9 → use A–F.
**Example:** 254 → ?

* 254 ÷ 16 = 15 remainder **14 (E)**
* 15 ÷ 16 = 0 remainder **15 (F)**
  👉 Hex = `FE`

---

### 🔹 E. Binary ↔ Octal / Hex (shortcut)

* Group binary digits:

  * **3 bits = 1 octal digit**
  * **4 bits = 1 hex digit**

**Example:** Binary `11010111` → Hex?
Group in 4: `1101 0111` = `D7`

**Example:** Binary `11010111` → Octal?
Group in 3: `110 101 111` = `657`

---

# 🟢 2. Logical / Bitwise Operators (Mathematical)

### 🔹 A. AND (`&`)

* Rule: 1 if both bits are 1.
* Example: `1011 & 1100 = 1000` (binary).

Mathematically → min(a,b).

* (1&0 = 0, 0&0 = 0, 1&1 = 1).

---

### 🔹 B. OR (`|`)

* Rule: 1 if at least one bit is 1.
* Example: `1011 | 1100 = 1111`.

Mathematically → max(a,b).

---

### 🔹 C. XOR (`^`)

* Rule: 1 if bits are different.
* Example: `1011 ^ 1100 = 0111`.

Mathematically → (a+b) mod 2.

* Used in toggling bits, parity checks, swap without temp.

---

### 🔹 D. NOT (`~`)

* Rule: Flip 1 → 0, 0 → 1.
* For signed numbers (two’s complement), `~x = -(x+1)`.

---

### 🔹 E. Shifts

* `x << n` → multiply by 2ⁿ.
* `x >> n` → divide by 2ⁿ (floor).

Example:

* `5 << 1 = 10` (binary `101 → 1010`).
* `20 >> 2 = 5` (binary `10100 → 101`).

---

# 🟢 3. Quick Tricks

* **Check even/odd:** `n & 1` → 0 = even, 1 = odd.
* **Swap without temp:** `a = a ^ b; b = a ^ b; a = a ^ b;`.
* **Clear lowest set bit:** `n & (n-1)`.
* **Get lowest set bit:** `n & -n`.
* **Power of 2 check:** `(n & (n-1)) == 0`.

---

# 🟢 4. Interview-Style Questions

1. **Convert 125 to binary without dividing repeatedly.**
   👉 Trick: Use powers of 2 directly. 125 = 64+32+16+8+4+1 → `1111101`.

2. **Why XOR is useful in coding interviews?**

* Property: `x ^ x = 0`, `x ^ 0 = x`.
* Used in finding the **single non-repeated element** in an array.

3. **Explain difference between signed right shift vs unsigned right shift.**

* Signed (`>>`): fills with sign bit (keeps negative/positive).
* Unsigned (`>>>`): fills with 0, always non-negative.

4. **How to quickly convert 11111111 (binary) to hex?**

* Group 4 bits: `1111 1111 = FF`.

5. **Given n = 40 (101000), clear the lowest set bit.**

* `n & (n-1) = 101000 & 100111 = 100000 (32)`.

---