# 🔹 Algorithm for 3Sum

**Problem statement:**
Given an array `nums`, return all unique triplets `[a, b, c]` such that:

```
a + b + c = 0
```

with `a, b, c` being elements of `nums`.

---

## Step 1: Sort the array

* Sorting makes it easy to use the two-pointer technique and skip duplicates.

---

## Step 2: Fix one element (outer loop → i)

* For each `i`, set:

  * `j = i + 1` (next element)
  * `k = n - 1` (last element)

---

## Step 3: Two-pointer check (inside while loop)

* Compute `sum = nums[i] + nums[j] + nums[k]`
* If:

  * `sum == 0` → found a valid triplet → store it → move both pointers (`j++` and `k--`) while skipping duplicates.
  * `sum < 0` → too small → increase `j` (to make sum bigger).
  * `sum > 0` → too large → decrease `k` (to make sum smaller).

---

## Step 4: Skip duplicates

* If `nums[i]` is the same as the previous, skip this iteration (avoid repeating triplets).
* Also skip duplicates when moving `j` and `k`.

---

## Step 5: Continue until all unique triplets are found.

---

# 📘 Pseudocode for 3Sum (Two-pointer Approach)

```
Algorithm ThreeSum(nums):
    Input: nums (array of integers)
    Output: list of unique triplets [a, b, c] such that a + b + c = 0

    1. sort(nums)                        // Step 1: Sort array
    2. res ← empty list                  // To store result triplets
    3. n ← length(nums)

    4. for i ← 0 to n - 3 do             // Step 2: Fix one number
           if i > 0 AND nums[i] = nums[i-1] then
                continue                 // Skip duplicate i values

           j ← i + 1                     // Step 3: Left pointer
           k ← n - 1                     // Step 3: Right pointer

           while j < k do
                sum ← nums[i] + nums[j] + nums[k]

                if sum = 0 then
                     add [nums[i], nums[j], nums[k]] to res
                     j ← j + 1
                     k ← k - 1

                     while j < k AND nums[j] = nums[j-1] do
                          j ← j + 1      // Skip duplicate j
                     while j < k AND nums[k] = nums[k+1] do
                          k ← k - 1      // Skip duplicate k

                else if sum < 0 then
                     j ← j + 1           // Need a larger sum
                else
                     k ← k - 1           // Need a smaller sum

    5. return res
```

---

# 📊 Complexity

* Sorting: **O(n log n)**
* Outer loop + two-pointer scan: **O(n²)**
* **Overall complexity = O(n²)** → lowest possible for this problem.

---

# 📘 Merge Sort — Full Explanation

Merge Sort is a **Divide and Conquer** algorithm. It works by:

1. Splitting the array into halves recursively until each piece has 1 element.
2. Merging those sorted pieces back together in the correct order.

---

## 🔹 Code with Line-by-Line Explanation

```js
/**
 * Merge two sorted halves of arr[left..mid] and arr[mid+1..right]
 */
function merge(arr, left, mid, right) {
```

* This function merges **two sorted parts** of the array.
* Left part = `arr[left..mid]`, Right part = `arr[mid+1..right]`.

---

```js
    let temp = [];
    let i = left;
    let j = mid + 1;
    let k = 0;
```

* `temp` is a helper array to store merged elements.
* `i` starts from the **left subarray**.
* `j` starts from the **right subarray**.
* `k` is the index for `temp`.

---

```js
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
```

* While both subarrays have elements:

  * Compare `arr[i]` and `arr[j]`.
  * Put the smaller one into `temp`.
  * Increment the pointer (`i` or `j`) and `k`.
* This ensures merging keeps the order sorted.

---

```js
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
```

* If **left subarray** still has elements, copy them.

---

```js
    while (j <= right) {
        temp[k++] = arr[j++];
    }
```

* If **right subarray** still has elements, copy them.

---

```js
    for (let t = 0; t < temp.length; t++) {
        arr[left + t] = temp[t];
    }
}
```

* Copy merged `temp` back into the original `arr` at the correct position (`arr[left..right]`).

---

```js
/**
 * Sort the array in-place using merge sort
 */
function mergeSort(arr, left, right) {
    if (left < right) {
```

* Base case: if subarray has **more than one element**, keep splitting.
* If `left >= right`, stop recursion (already sorted).

---

```js
        let mid = Math.floor((left + right) / 2);
```

* Find middle index to divide array into two halves.

---

```js
        mergeSort(arr, left, mid);       // Sort left half
        mergeSort(arr, mid + 1, right);  // Sort right half
```

* Recursively call `mergeSort` on both halves.

---

```js
        merge(arr, left, mid, right);    // Merge sorted halves
    }
}
```

* After sorting both halves, **merge** them back into a sorted array.

---

```js
module.exports = { mergeSort };
```

* Allows exporting the function for **Node.js** usage.

---

## 🔹 Dry Run Example

Input:

```
arr = [38, 27, 43, 3, 9, 82, 10]
```

1. Split into halves:

   ```
   [38, 27, 43, 3]  and  [9, 82, 10]
   ```
2. Keep splitting until single elements:

   ```
   [38] [27] [43] [3]   [9] [82] [10]
   ```
3. Merge step by step:

   ```
   [27, 38] [3, 43]  →  [3, 27, 38, 43]
   [9, 82] [10]      →  [9, 10, 82]
   ```
4. Final merge:

   ```
   [3, 9, 10, 27, 38, 43, 82]
   ```

---

# 🔹 Algorithm (Step-by-Step)

1. If `left < right`:

   * Find `mid = (left + right) / 2`
   * Recursively sort `arr[left..mid]`
   * Recursively sort `arr[mid+1..right]`
   * Merge both halves with `merge(arr, left, mid, right)`
2. If `left >= right`, stop (subarray of length 1 is sorted).

---

# 🔹 Pseudocode

```
MERGE-SORT(arr, left, right):
    if left < right:
        mid = (left + right) / 2
        MERGE-SORT(arr, left, mid)
        MERGE-SORT(arr, mid+1, right)
        MERGE(arr, left, mid, right)

MERGE(arr, left, mid, right):
    create empty temp array
    i = left
    j = mid + 1
    k = 0

    while i ≤ mid and j ≤ right:
        if arr[i] ≤ arr[j]:
            temp[k] = arr[i]
            i = i + 1
        else:
            temp[k] = arr[j]
            j = j + 1
        k = k + 1

    while i ≤ mid:
        temp[k] = arr[i]
        i = i + 1
        k = k + 1

    while j ≤ right:
        temp[k] = arr[j]
        j = j + 1
        k = k + 1

    for t = 0 to length(temp)-1:
        arr[left + t] = temp[t]
```

---

# 🔹 Complexity Analysis

* **Time Complexity:**

  * Splitting: O(log n) levels
  * Merging at each level: O(n)
  * → Overall: **O(n log n)**
* **Space Complexity:** O(n) (for temp array)
* **Stable:** Yes (preserves order of equal elements).

---
