# 1. Subsets (LeetCode 78 / GFG Subsets)

---

## Problem Understanding

* Generate **all possible subsets** (power set) of a given array `nums`.
* Each element can either be **included or excluded**.
* Order of subsets does not matter.

---

## Approach

* Use **backtracking / recursion**:

  1. At each index, **pick** the element → include in current subset `cur`.
  2. Recurse for next index.
  3. **Backtrack** → remove element from `cur`.
  4. **Not pick** → recurse without including element.

---

## Algorithm

1. Initialize `ans = []` to store subsets and `cur = []` as current subset.
2. Recursive function `answer(nums, cur, i)`:

   * **Base case:** If `i == nums.length`, add a copy of `cur` to `ans`.
   * **Pick**: `cur.push(nums[i])`, recurse `i+1`, then `cur.pop()` (backtrack).
   * **Not pick**: recurse `i+1`.
3. Return `ans`.

---

## Pseudocode

```
FUNCTION subsets(nums):
    ans = []
    cur = []
    FUNCTION answer(nums, cur, i):
        IF i == length(nums):
            ans.push(copy(cur))
            RETURN
        cur.push(nums[i])
        answer(nums, cur, i+1)
        cur.pop()
        answer(nums, cur, i+1)
    CALL answer(nums, cur, 0)
    RETURN ans
```

---

## Dry Run Example (nums = [1,2])

```
i=0, cur=[]
Pick 1 -> cur=[1]
  i=1, Pick 2 -> cur=[1,2] -> add [1,2]
  Backtrack -> cur=[1], Not Pick 2 -> add [1]
Backtrack -> cur=[], Not Pick 1
  i=1, Pick 2 -> cur=[2] -> add [2]
  Not Pick 2 -> add []
Result: [ [1,2], [1], [2], [] ]
```

---

# 2. Subsets II (LeetCode 90)

---

## Problem Understanding

* Generate **all possible subsets** of a given array `nums` **which may contain duplicates**.
* **No duplicate subsets** should be returned.

---

## Approach

* **Sort the array** first to bring duplicates together.
* Use **backtracking / recursion**:

  1. At each index, **pick** the element → include in `cur`.
  2. Recurse for next index.
  3. **Backtrack** → remove element from `cur`.
  4. **Skip duplicates** when not picking:

     * Increment index `i` while `nums[i] == nums[i+1]` to avoid duplicate subsets.
  5. **Not pick** → recurse after skipping duplicates.

---

## Algorithm

1. Sort `nums`.
2. Initialize `ans = []` and `cur = []`.
3. Recursive function `answer(i)`:

   * **Base case:** If `i == nums.length`, push a copy of `cur` into `ans`.
   * **Pick:** `cur.push(nums[i])`, recurse `i+1`, then `cur.pop()`.
   * **Skip duplicates:** while `i+1 < nums.length` and `nums[i] == nums[i+1]`, increment `i`.
   * **Not pick:** recurse `i+1`.
4. Return `ans`.

---

## Pseudocode

```
FUNCTION subsetsWithDup(nums):
    sort(nums)
    ans = [], cur=[]
    FUNCTION answer(i):
        IF i == length(nums):
            ans.push(copy(cur))
            RETURN
        cur.push(nums[i])
        answer(i+1)          // Pick
        cur.pop()
        WHILE i+1 < length(nums) AND nums[i] == nums[i+1]:
            i++
        answer(i+1)          // Not Pick
    CALL answer(0)
    RETURN ans
```

---

## Dry Run Example (nums = [1,2,2])

```
i=0, cur=[]
Pick 1 -> cur=[1]
  i=1, Pick 2 -> cur=[1,2]
    i=2, Pick 2 -> cur=[1,2,2] -> add [1,2,2]
    Backtrack -> cur=[1,2], Not Pick 2 -> add [1,2]
  Backtrack -> cur=[1], Not Pick 2 (skip duplicates) -> add [1]
Backtrack -> cur=[], Not Pick 1
  i=1, Pick 2 -> cur=[2]
    i=2, Pick 2 -> cur=[2,2] -> add [2,2]
    Backtrack -> cur=[2], Not Pick 2 -> add [2]
  Not Pick 1 (skip duplicates) -> add []
Result: [ [1,2,2], [1,2], [1], [2,2], [2], [] ]
```
---

# 3. Power Set (GFG)

---

## Problem Understanding

* Generate **all possible subsets** (power set) of a given **string `s`**.
* Each character can be **included or excluded** in a subset.
* Return **all subsets as strings**, optionally sorted.

---

## Approach

* Use **backtracking / recursion**:

  1. At each index `i`:

     * **Pick** the character → append `s[i]` to `cur`.
     * Recurse to `i+1`.
     * **Not pick** → keep `cur` unchanged and recurse to `i+1`.
  2. Base case: when `i == s.length`, store `cur` in the answer array.

* After generating all subsets:

  * Optionally filter for non-empty subsets.
  * Sort subsets if required.

---

## Algorithm

1. Initialize `ans = []`.
2. Recursive function `answer(s, cur, i)`:

   * **Base case:** If `i == s.length`, push `cur` to `ans`.
   * **Pick:** `cur + s[i]`, recurse `i+1`.
   * **Not pick:** `cur`, recurse `i+1`.
3. Filter subsets if needed and sort the result.
4. Return the final array.

---

## Pseudocode

```
FUNCTION AllPossibleStrings(s):
    ans = []
    FUNCTION answer(s, cur, i):
        IF i == length(s):
            ans.push(cur)
            RETURN
        answer(s, cur + s[i], i+1)   // Pick
        answer(s, cur, i+1)          // Not Pick
    CALL answer(s, '', 0)
    result = filter(ans)            // Optional filtering
    sort(result)                    // Optional sorting
    RETURN result
```

---

## Dry Run Example (s = "ab")

```
i=0, cur=""
Pick 'a' -> cur="a"
  i=1, Pick 'b' -> cur="ab" -> add "ab"
  Not Pick 'b' -> cur="a" -> add "a"
Backtrack -> cur=""
Not Pick 'a'
  i=1, Pick 'b' -> cur="b" -> add "b"
  Not Pick 'b' -> cur="" -> add ""
Result: ["ab", "a", "b", ""]
```
---

# 4. Permutations (LeetCode 46)

---

## Problem Understanding

* Generate **all possible arrangements (permutations)** of a given array `nums`.
* Elements are **unique**.
* Return an array of all permutations.

---

## Approach

### 1. Backtracking with Visited Array

1. Maintain:

   * `cur` → current permutation being built.
   * `isVis` → boolean array to track used elements.
2. For each position:

   * Loop through `nums`.
   * If element not used, mark as visited, add to `cur`, recurse for next index.
   * After recursion, backtrack by unmarking visited and removing element from `cur`.

### 2. Optimal Swap Method

1. Swap elements in-place to generate permutations:

   * For index `i`, swap with all elements from `i` to `n-1`.
   * Recurse `i+1`.
   * Backtrack by swapping back.
2. Avoids extra memory for `isVis` array.

---

## Algorithm (Swap Method)

1. Initialize `ans = []`.
2. Recursive function `answer(i, cur)`:

   * **Base case:** If `i == length(cur)`, push copy of `cur` to `ans`.
   * Loop `j` from `i` to `length(cur)-1`:

     * Swap `cur[i]` and `cur[j]`.
     * Recurse `i+1`.
     * Swap back to backtrack.
3. Call `answer(0, nums.slice())`.
4. Return `ans`.

---

## Pseudocode

```
FUNCTION permute(nums):
    ans = []
    FUNCTION answer(i, cur):
        IF i == length(cur):
            ans.push(copy(cur))
            RETURN
        FOR j = i to length(cur)-1:
            swap(cur[i], cur[j])
            answer(i+1, cur)
            swap(cur[i], cur[j])
    CALL answer(0, copy(nums))
    RETURN ans
```

---

## Dry Run Example (nums = [1,2])

```
i=0, cur=[1,2]
j=0, swap 0,0 -> [1,2]
  i=1
    j=1, swap 1,1 -> [1,2] -> add [1,2]
  Backtrack
j=1, swap 0,1 -> [2,1]
  i=1
    j=1, swap 1,1 -> [2,1] -> add [2,1]
  Backtrack
Result: [[1,2],[2,1]]
```
---

# 5. Permutations II (LeetCode 47)

---

## Problem Understanding

* Generate **all unique permutations** of a given array `nums` which **may contain duplicates**.
* Avoid duplicate permutations in the result.

---

## Approach

* Use **backtracking with swap and set**:

  1. For each recursion level `i`:

     * Maintain a **set** to track elements already used at this position.
     * Loop `j` from `i` to `n-1`.
     * Skip if `nums[j]` already exists in the set.
     * Otherwise:

       * Add `nums[j]` to the set.
       * Swap `nums[i]` with `nums[j]`.
       * Recurse `i+1`.
       * Swap back to backtrack.

* This ensures **duplicates are avoided** without needing to sort the array beforehand.

---

## Algorithm

1. Initialize `ans = []`.
2. Recursive function `answer(i)`:

   * **Base case:** If `i == nums.length`, push a copy of `nums` to `ans`.
   * Initialize empty `set` for the current recursion level.
   * Loop `j` from `i` to `nums.length-1`:

     * If `nums[j]` in set → continue.
     * Else:

       * Add `nums[j]` to set.
       * Swap `nums[i]` and `nums[j]`.
       * Recurse `i+1`.
       * Swap back to backtrack.
3. Call `answer(0)`.
4. Return `ans`.

---

## Pseudocode

```
FUNCTION permuteUnique(nums):
    ans = []
    FUNCTION answer(i):
        IF i == length(nums):
            ans.push(copy(nums))
            RETURN
        set = empty set
        FOR j = i to length(nums)-1:
            IF nums[j] in set: CONTINUE
            set.add(nums[j])
            swap(nums[i], nums[j])
            answer(i+1)
            swap(nums[i], nums[j])
    CALL answer(0)
    RETURN ans
```

---

## Dry Run Example (nums = [1,1,2])

```
i=0, cur=[1,1,2], set={}
j=0, 1 not in set -> add 1, swap 0,0 -> [1,1,2]
  i=1, set={}
    j=1, 1 not in set -> add 1, swap 1,1 -> [1,1,2]
      i=2
        j=2, swap 2,2 -> [1,1,2] -> add [1,1,2]
    Backtrack
    j=2, 2 not in set -> add 2, swap 1,2 -> [1,2,1]
      i=2
        j=2, swap 2,2 -> [1,2,1] -> add [1,2,1]
  Backtrack
j=1, 1 in set -> skip
j=2, 2 not in set -> add 2, swap 0,2 -> [2,1,1]
  i=1, set={}
    j=1, 1 not in set -> add 1, swap 1,1 -> [2,1,1]
      i=2
        j=2, swap 2,2 -> [2,1,1] -> add [2,1,1]
    j=2, 1 in set -> skip
Backtrack
Result: [[1,1,2],[1,2,1],[2,1,1]]
```
