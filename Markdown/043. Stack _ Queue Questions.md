# Valid Parentheses (LeetCode 20)

---

### 📘 Explanation

We are given a string `s` containing only brackets: `()`, `{}`, and `[]`.
We need to check if the string is **valid**. A string is valid if:

1. Every opening bracket has a matching closing bracket.
2. Brackets are closed in the correct order.

For example:

* `"()"` → ✅ valid
* `"()[]{}"` → ✅ valid
* `"(]"` → ❌ invalid
* `"([)]"` → ❌ invalid

We solve this using a **stack**.

---

### 📝 Algorithm (Step-by-step)

1. Create an empty stack.
2. Traverse the string character by character.
3. If the character is an **opening bracket** `(`, `{`, `[`, push it onto stack.
4. If the character is a **closing bracket** `)`, `}`, `]`:

   * If stack is empty → invalid (no opening bracket).
   * Otherwise pop from stack and check if it matches the correct opening bracket.
   * If not matching → invalid.
5. After traversal, if stack is empty → string is valid.
   Otherwise → invalid.

---

### 🔑 Pseudocode

```
function isValid(s):
    map = { ")":"(", "}":"{", "]":"[" }
    stack = []
    
    for char in s:
        if char is opening bracket:
            push char into stack
        else:
            if stack empty OR stack.pop() != map[char]:
                return false
    
    return stack empty
```

---

### 🧮 Dry Run

Input: `"([{}])"`

stack=[]

char='(' → push → stack=['(']
char='[' → push → stack=['(', '[']
char='{' → push → stack=['(', '[', '{']
char='}' → pop='{', matches opening → stack=['(', '[']
char=']' → pop='[', matches opening → stack=['(']
char=')' → pop='(', matches opening → stack=[]

✅ Stack empty → Valid

---

### 🖼️ Flowchart

```
         ┌────────────┐
         │ Start       │
         └─────┬──────┘
               │
      ┌────────▼─────────┐
      │ Initialize stack  │
      └────────┬─────────┘
               │
 ┌─────────────▼─────────────┐
 │ For each char in string   │
 │   If opening bracket      │
 │       push into stack     │
 │   Else (closing bracket)  │
 │       If stack empty      │
 │           return false    │
 │       If pop != match     │
 │           return false    │
 └─────────────┬─────────────┘
               │
      ┌────────▼────────┐
      │ If stack empty  │
      │   return true   │
      │ Else return false│
      └─────────────────┘
```

---

### 👦 Explanation for a 10-year-old Indian kid

Think of brackets as **lock and key pairs**.

* `(` is a lock, `)` is the matching key.
* `{` is a lock, `}` is the matching key.
* `[` is a lock, `]` is the matching key.

To check if string is valid:
👉 Every lock must be closed by its correct key in the right order.

We use a **stack** like a bag:

* Whenever you see a lock, put it inside.
* Whenever you see a key, open the last lock from the bag.
* If at the end bag is empty → all locks closed → string valid.

---

### ✨ Easy Second Look (Beginner’s view)

* Opening bracket → push into stack.
* Closing bracket → pop and check.
* Wrong match or empty stack → invalid.
* End with empty stack → valid.

That’s it → Valid Parentheses solved easily!

---

# Online Stock Span (LeetCode 901)

---

### 📘 Explanation

We are designing a system where every time we get today’s stock price, we must return its **span** → the number of consecutive days before today (including today) where stock price was **less than or equal** to today’s price.

Example:
Input stream: `100, 80, 60, 70, 60, 75, 85`
Output spans: `1, 1, 1, 2, 1, 4, 6`

We use a **stack** to solve it efficiently. Each entry in stack = `[price, span]`.

---

### 📝 Algorithm (Step-by-step)

1. Initialize an empty stack.
2. When a new price arrives:

   * Set `span = 1` (at least today counts).
   * While stack not empty and top price ≤ current price:

     * Pop from stack and add its span to `span`.
   * Push `[current price, span]` into stack.
   * Return `span`.

---

### 🔑 Pseudocode

```
class StockSpanner:
    stack = []

    function next(price):
        span = 1
        while stack not empty AND stack.top.price <= price:
            span += stack.pop().span
        stack.push([price, span])
        return span
```

---

### 🧮 Dry Run

Input stream: [100, 80, 60, 70, 60, 75, 85]

Day 1: price=100 → stack empty → span=1 → push [100,1] → Output=1
Day 2: price=80 → top=100>80 → span=1 → push [80,1] → Output=1
Day 3: price=60 → top=80>60 → span=1 → push [60,1] → Output=1
Day 4: price=70 → top=60≤70 → pop [60,1], span=2 → push [70,2] → Output=2
Day 5: price=60 → top=70>60 → span=1 → push [60,1] → Output=1
Day 6: price=75 → top=60≤75 → pop [60,1], span=2
→ top=70≤75 → pop [70,2], span=4 → push [75,4] → Output=4
Day 7: price=85 → top=75≤85 → pop [75,4], span=5
→ top=80≤85 → pop [80,1], span=6 → push [85,6] → Output=6

✅ Final Outputs = [1, 1, 1, 2, 1, 4, 6]

---

### 🖼️ Flowchart

```
          ┌────────────┐
          │ Start       │
          └─────┬──────┘
                │
        ┌───────▼───────────┐
        │ Initialize stack   │
        └────────┬──────────┘
                 │
     ┌───────────▼─────────────┐
     │ For each new price      │
     │   span = 1              │
     │   While stack.top.price │
     │         <= current price│
     │       span += stack.pop().span │
     │   Push [price,span]     │
     │   Return span           │
     └───────────┬─────────────┘
                 │
          ┌──────▼──────┐
          │ Continue... │
          └─────────────┘
```

---

### 👦 Explanation for a 10-year-old Indian kid

Imagine cricket runs written on a board every day. For today, you want to know:
👉 “How many days continuously before today had **less or equal runs** compared to today?”

We use a **stack of days**:

* Each day stores `[runs, span]`.
* If today’s runs are higher, we remove those smaller days and add their spans to today’s span.
* That gives us today’s answer.

---

### ✨ Easy Second Look (Beginner’s view)

* Keep stack of `[price, span]`.
* Today starts with span=1.
* Pop smaller/equal prices and add their spans.
* Push today’s data, return span.

That’s it → Online Stock Span solved easily!

---

# Implement Stack using Queues (LeetCode 225)

---

### 📘 Explanation

We need to build a **stack** (LIFO → Last In First Out) using only **queues** (FIFO → First In First Out).

Stack operations:

* `push(x)` → insert element
* `pop()` → remove top element
* `top()` → get top element
* `empty()` → check if stack is empty

We use **two queues** to simulate stack behavior.

---

### 📝 Algorithm (Step-by-step)

1. Maintain two queues: `q1` (main) and `q2` (helper).
2. For `push(x)`:

   * Add `x` to `q2`.
   * Move all elements from `q1` into `q2`.
   * Swap names of `q1` and `q2`.
   * Now `q1` has the correct order (top at front).
3. For `pop()`: remove element from front of `q1`.
4. For `top()`: return front element of `q1`.
5. For `empty()`: return true if `q1` is empty.

---

### 🔑 Pseudocode

```
class MyStack:
    q1 = []
    q2 = []

    function push(x):
        enqueue x into q2
        while q1 not empty:
            enqueue dequeue(q1) into q2
        swap q1 and q2

    function pop():
        if q1 empty: return null
        return dequeue(q1)

    function top():
        if q1 empty: return null
        return q1.front()

    function empty():
        return q1 is empty
```

---

### 🧮 Dry Run

Operations:
push(1), push(2), top(), pop(), empty()

Step 1: push(1)
q2=[1], move q1=[], swap → q1=[1]

Step 2: push(2)
q2=[2], move q1=[1] → q2=[2,1], swap → q1=[2,1]

Step 3: top() → front of q1 = 2

Step 4: pop() → remove front of q1 = 2 → q1=[1]

Step 5: empty() → q1 not empty → false

✅ Output sequence = [null, null, 2, 2, false]

---

### 🖼️ Flowchart

```
         ┌────────────┐
         │ Start       │
         └─────┬──────┘
               │
      ┌────────▼─────────┐
      │ q1 = [], q2 = [] │
      └────────┬─────────┘
               │
     ┌─────────▼───────────┐
     │ push(x):            │
     │  enqueue x→q2       │
     │  move q1→q2         │
     │  swap(q1,q2)        │
     └─────────┬───────────┘
               │
     ┌─────────▼───────────┐
     │ pop(): dequeue q1   │
     └─────────┬───────────┘
               │
     ┌─────────▼───────────┐
     │ top(): front of q1  │
     └─────────┬───────────┘
               │
     ┌─────────▼───────────┐
     │ empty(): q1 empty?  │
     └─────────────────────┘
```

---

### 👦 Explanation for a 10-year-old Indian kid

Think of a **stack** like a pile of plates in the kitchen → you can only take from the **top**.

But here you are forced to use **queues** (like people standing in line, first comes first goes).

So trick:

* Every time you push a new plate, put it in a new line (q2).
* Then move all the old plates behind it.
* Swap lines → now the newest plate is at the front of the main line (q1).
* That way you can pop or see the top easily.

---

### ✨ Easy Second Look (Beginner’s view)

* Use 2 queues.
* `push`: add to q2, move q1 to q2, swap.
* `pop`: remove from q1 front.
* `top`: peek q1 front.
* `empty`: check q1 empty.

That’s it → Stack using Queues solved easily!

---

# Implement Queue using Stacks (LeetCode 232)

---

### 📘 Explanation

We need to build a **queue** (FIFO → First In First Out) using **stacks** (LIFO → Last In First Out).

Queue operations:

* `push(x)` → insert element at back
* `pop()` → remove element from front
* `peek()` → get front element
* `empty()` → check if queue is empty

We use **two stacks** (`stackIn`, `stackOut`) to manage this.

---

### 📝 Algorithm (Step-by-step)

1. Maintain two stacks:

   * `stackIn` → for inserting new elements.
   * `stackOut` → for removing/peeking elements.
2. For `push(x)`: simply push into `stackIn`.
3. For `pop()`:

   * If `stackOut` is empty → move all elements from `stackIn` to `stackOut`.
   * Then pop from `stackOut`.
4. For `peek()`:

   * If `stackOut` is empty → move all elements from `stackIn` to `stackOut`.
   * Return top of `stackOut`.
5. For `empty()`: return true if both stacks are empty.

---

### 🔑 Pseudocode

```
class MyQueue:
    stackIn = []
    stackOut = []

    function push(x):
        stackIn.push(x)

    function pop():
        if stackOut is empty:
            while stackIn not empty:
                stackOut.push(stackIn.pop())
        return stackOut.pop()

    function peek():
        if stackOut is empty:
            while stackIn not empty:
                stackOut.push(stackIn.pop())
        return stackOut.top()

    function empty():
        return stackIn empty AND stackOut empty
```

---

### 🧮 Dry Run

Operations:
push(1), push(2), peek(), pop(), empty()

Step 1: push(1)
stackIn=[1], stackOut=[]

Step 2: push(2)
stackIn=[1,2], stackOut=[]

Step 3: peek()
stackOut empty → move stackIn → stackOut=[2,1]
peek → top of stackOut = 1

Step 4: pop()
pop from stackOut → removes 1
stackOut=[2]

Step 5: empty()
stackIn=[], stackOut=[2] → false

✅ Output sequence = [null, null, 1, 1, false]

---

### 🖼️ Flowchart

```
         ┌────────────┐
         │   Start     │
         └─────┬──────┘
               │
      ┌────────▼───────────┐
      │ stackIn = [],      │
      │ stackOut = []      │
      └────────┬───────────┘
               │
     ┌─────────▼─────────────┐
     │ push(x):               │
     │   stackIn.push(x)      │
     └─────────┬─────────────┘
               │
     ┌─────────▼─────────────┐
     │ pop():                 │
     │ if stackOut empty:     │
     │   move stackIn→stackOut│
     │ return stackOut.pop()  │
     └─────────┬─────────────┘
               │
     ┌─────────▼─────────────┐
     │ peek():                │
     │ if stackOut empty:     │
     │   move stackIn→stackOut│
     │ return stackOut.top()  │
     └─────────┬─────────────┘
               │
     ┌─────────▼─────────────┐
     │ empty():               │
     │ return both empty?     │
     └───────────────────────┘
```

---

### 👦 Explanation for a 10-year-old Indian kid

Think of a **queue** like a line at the ration shop → the person who comes first gets served first.

But you only have **stacks** (like a pile of books, take from top).

Trick:

* When someone joins the line → put them in `stackIn`.
* When you need to serve (pop) or see front → if `stackOut` is empty, flip all books from `stackIn` into `stackOut`.
* Now the oldest person is on top of `stackOut`, ready to serve first.

---

### ✨ Easy Second Look (Beginner’s view)

* Use 2 stacks.
* `push`: add to stackIn.
* `pop`: if stackOut empty, move stackIn to stackOut, then pop.
* `peek`: same as pop but just see.
* `empty`: check both empty.

That’s it → Queue using Stacks solved easily!

---


