# Valid Parentheses (LeetCode 20)

---

### ğŸ“˜ Explanation

We are given a string `s` containing only brackets: `()`, `{}`, and `[]`.
We need to check if the string is **valid**. A string is valid if:

1. Every opening bracket has a matching closing bracket.
2. Brackets are closed in the correct order.

For example:

* `"()"` â†’ âœ… valid
* `"()[]{}"` â†’ âœ… valid
* `"(]"` â†’ âŒ invalid
* `"([)]"` â†’ âŒ invalid

We solve this using a **stack**.

---

### ğŸ“ Algorithm (Step-by-step)

1. Create an empty stack.
2. Traverse the string character by character.
3. If the character is an **opening bracket** `(`, `{`, `[`, push it onto stack.
4. If the character is a **closing bracket** `)`, `}`, `]`:

   * If stack is empty â†’ invalid (no opening bracket).
   * Otherwise pop from stack and check if it matches the correct opening bracket.
   * If not matching â†’ invalid.
5. After traversal, if stack is empty â†’ string is valid.
   Otherwise â†’ invalid.

---

### ğŸ”‘ Pseudocode

```
function isValid(s):
    map = { ")":"(", "}":"{", "]":"[" }
    stack = []
    
    for char in s:
        if char is opening bracket:
            push char into stack
        else:
            if stack empty OR stack.pop() != map[char]:
                return false
    
    return stack empty
```

---

### ğŸ§® Dry Run

Input: `"([{}])"`

stack=[]

char='(' â†’ push â†’ stack=['(']
char='[' â†’ push â†’ stack=['(', '[']
char='{' â†’ push â†’ stack=['(', '[', '{']
char='}' â†’ pop='{', matches opening â†’ stack=['(', '[']
char=']' â†’ pop='[', matches opening â†’ stack=['(']
char=')' â†’ pop='(', matches opening â†’ stack=[]

âœ… Stack empty â†’ Valid

---

### ğŸ–¼ï¸ Flowchart

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Start       â”‚
         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Initialize stack  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ For each char in string   â”‚
 â”‚   If opening bracket      â”‚
 â”‚       push into stack     â”‚
 â”‚   Else (closing bracket)  â”‚
 â”‚       If stack empty      â”‚
 â”‚           return false    â”‚
 â”‚       If pop != match     â”‚
 â”‚           return false    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ If stack empty  â”‚
      â”‚   return true   â”‚
      â”‚ Else return falseâ”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ‘¦ Explanation for a 10-year-old Indian kid

Think of brackets as **lock and key pairs**.

* `(` is a lock, `)` is the matching key.
* `{` is a lock, `}` is the matching key.
* `[` is a lock, `]` is the matching key.

To check if string is valid:
ğŸ‘‰ Every lock must be closed by its correct key in the right order.

We use a **stack** like a bag:

* Whenever you see a lock, put it inside.
* Whenever you see a key, open the last lock from the bag.
* If at the end bag is empty â†’ all locks closed â†’ string valid.

---

### âœ¨ Easy Second Look (Beginnerâ€™s view)

* Opening bracket â†’ push into stack.
* Closing bracket â†’ pop and check.
* Wrong match or empty stack â†’ invalid.
* End with empty stack â†’ valid.

Thatâ€™s it â†’ Valid Parentheses solved easily!

---

# Online Stock Span (LeetCode 901)

---

### ğŸ“˜ Explanation

We are designing a system where every time we get todayâ€™s stock price, we must return its **span** â†’ the number of consecutive days before today (including today) where stock price was **less than or equal** to todayâ€™s price.

Example:
Input stream: `100, 80, 60, 70, 60, 75, 85`
Output spans: `1, 1, 1, 2, 1, 4, 6`

We use a **stack** to solve it efficiently. Each entry in stack = `[price, span]`.

---

### ğŸ“ Algorithm (Step-by-step)

1. Initialize an empty stack.
2. When a new price arrives:

   * Set `span = 1` (at least today counts).
   * While stack not empty and top price â‰¤ current price:

     * Pop from stack and add its span to `span`.
   * Push `[current price, span]` into stack.
   * Return `span`.

---

### ğŸ”‘ Pseudocode

```
class StockSpanner:
    stack = []

    function next(price):
        span = 1
        while stack not empty AND stack.top.price <= price:
            span += stack.pop().span
        stack.push([price, span])
        return span
```

---

### ğŸ§® Dry Run

Input stream: [100, 80, 60, 70, 60, 75, 85]

Day 1: price=100 â†’ stack empty â†’ span=1 â†’ push [100,1] â†’ Output=1
Day 2: price=80 â†’ top=100>80 â†’ span=1 â†’ push [80,1] â†’ Output=1
Day 3: price=60 â†’ top=80>60 â†’ span=1 â†’ push [60,1] â†’ Output=1
Day 4: price=70 â†’ top=60â‰¤70 â†’ pop [60,1], span=2 â†’ push [70,2] â†’ Output=2
Day 5: price=60 â†’ top=70>60 â†’ span=1 â†’ push [60,1] â†’ Output=1
Day 6: price=75 â†’ top=60â‰¤75 â†’ pop [60,1], span=2
â†’ top=70â‰¤75 â†’ pop [70,2], span=4 â†’ push [75,4] â†’ Output=4
Day 7: price=85 â†’ top=75â‰¤85 â†’ pop [75,4], span=5
â†’ top=80â‰¤85 â†’ pop [80,1], span=6 â†’ push [85,6] â†’ Output=6

âœ… Final Outputs = [1, 1, 1, 2, 1, 4, 6]

---

### ğŸ–¼ï¸ Flowchart

```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Start       â”‚
          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Initialize stack   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ For each new price      â”‚
     â”‚   span = 1              â”‚
     â”‚   While stack.top.price â”‚
     â”‚         <= current priceâ”‚
     â”‚       span += stack.pop().span â”‚
     â”‚   Push [price,span]     â”‚
     â”‚   Return span           â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
          â”‚ Continue... â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ‘¦ Explanation for a 10-year-old Indian kid

Imagine cricket runs written on a board every day. For today, you want to know:
ğŸ‘‰ â€œHow many days continuously before today had **less or equal runs** compared to today?â€

We use a **stack of days**:

* Each day stores `[runs, span]`.
* If todayâ€™s runs are higher, we remove those smaller days and add their spans to todayâ€™s span.
* That gives us todayâ€™s answer.

---

### âœ¨ Easy Second Look (Beginnerâ€™s view)

* Keep stack of `[price, span]`.
* Today starts with span=1.
* Pop smaller/equal prices and add their spans.
* Push todayâ€™s data, return span.

Thatâ€™s it â†’ Online Stock Span solved easily!

---

# Implement Stack using Queues (LeetCode 225)

---

### ğŸ“˜ Explanation

We need to build a **stack** (LIFO â†’ Last In First Out) using only **queues** (FIFO â†’ First In First Out).

Stack operations:

* `push(x)` â†’ insert element
* `pop()` â†’ remove top element
* `top()` â†’ get top element
* `empty()` â†’ check if stack is empty

We use **two queues** to simulate stack behavior.

---

### ğŸ“ Algorithm (Step-by-step)

1. Maintain two queues: `q1` (main) and `q2` (helper).
2. For `push(x)`:

   * Add `x` to `q2`.
   * Move all elements from `q1` into `q2`.
   * Swap names of `q1` and `q2`.
   * Now `q1` has the correct order (top at front).
3. For `pop()`: remove element from front of `q1`.
4. For `top()`: return front element of `q1`.
5. For `empty()`: return true if `q1` is empty.

---

### ğŸ”‘ Pseudocode

```
class MyStack:
    q1 = []
    q2 = []

    function push(x):
        enqueue x into q2
        while q1 not empty:
            enqueue dequeue(q1) into q2
        swap q1 and q2

    function pop():
        if q1 empty: return null
        return dequeue(q1)

    function top():
        if q1 empty: return null
        return q1.front()

    function empty():
        return q1 is empty
```

---

### ğŸ§® Dry Run

Operations:
push(1), push(2), top(), pop(), empty()

Step 1: push(1)
q2=[1], move q1=[], swap â†’ q1=[1]

Step 2: push(2)
q2=[2], move q1=[1] â†’ q2=[2,1], swap â†’ q1=[2,1]

Step 3: top() â†’ front of q1 = 2

Step 4: pop() â†’ remove front of q1 = 2 â†’ q1=[1]

Step 5: empty() â†’ q1 not empty â†’ false

âœ… Output sequence = [null, null, 2, 2, false]

---

### ğŸ–¼ï¸ Flowchart

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Start       â”‚
         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ q1 = [], q2 = [] â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ push(x):            â”‚
     â”‚  enqueue xâ†’q2       â”‚
     â”‚  move q1â†’q2         â”‚
     â”‚  swap(q1,q2)        â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ pop(): dequeue q1   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ top(): front of q1  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ empty(): q1 empty?  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ‘¦ Explanation for a 10-year-old Indian kid

Think of a **stack** like a pile of plates in the kitchen â†’ you can only take from the **top**.

But here you are forced to use **queues** (like people standing in line, first comes first goes).

So trick:

* Every time you push a new plate, put it in a new line (q2).
* Then move all the old plates behind it.
* Swap lines â†’ now the newest plate is at the front of the main line (q1).
* That way you can pop or see the top easily.

---

### âœ¨ Easy Second Look (Beginnerâ€™s view)

* Use 2 queues.
* `push`: add to q2, move q1 to q2, swap.
* `pop`: remove from q1 front.
* `top`: peek q1 front.
* `empty`: check q1 empty.

Thatâ€™s it â†’ Stack using Queues solved easily!

---

# Implement Queue using Stacks (LeetCode 232)

---

### ğŸ“˜ Explanation

We need to build a **queue** (FIFO â†’ First In First Out) using **stacks** (LIFO â†’ Last In First Out).

Queue operations:

* `push(x)` â†’ insert element at back
* `pop()` â†’ remove element from front
* `peek()` â†’ get front element
* `empty()` â†’ check if queue is empty

We use **two stacks** (`stackIn`, `stackOut`) to manage this.

---

### ğŸ“ Algorithm (Step-by-step)

1. Maintain two stacks:

   * `stackIn` â†’ for inserting new elements.
   * `stackOut` â†’ for removing/peeking elements.
2. For `push(x)`: simply push into `stackIn`.
3. For `pop()`:

   * If `stackOut` is empty â†’ move all elements from `stackIn` to `stackOut`.
   * Then pop from `stackOut`.
4. For `peek()`:

   * If `stackOut` is empty â†’ move all elements from `stackIn` to `stackOut`.
   * Return top of `stackOut`.
5. For `empty()`: return true if both stacks are empty.

---

### ğŸ”‘ Pseudocode

```
class MyQueue:
    stackIn = []
    stackOut = []

    function push(x):
        stackIn.push(x)

    function pop():
        if stackOut is empty:
            while stackIn not empty:
                stackOut.push(stackIn.pop())
        return stackOut.pop()

    function peek():
        if stackOut is empty:
            while stackIn not empty:
                stackOut.push(stackIn.pop())
        return stackOut.top()

    function empty():
        return stackIn empty AND stackOut empty
```

---

### ğŸ§® Dry Run

Operations:
push(1), push(2), peek(), pop(), empty()

Step 1: push(1)
stackIn=[1], stackOut=[]

Step 2: push(2)
stackIn=[1,2], stackOut=[]

Step 3: peek()
stackOut empty â†’ move stackIn â†’ stackOut=[2,1]
peek â†’ top of stackOut = 1

Step 4: pop()
pop from stackOut â†’ removes 1
stackOut=[2]

Step 5: empty()
stackIn=[], stackOut=[2] â†’ false

âœ… Output sequence = [null, null, 1, 1, false]

---

### ğŸ–¼ï¸ Flowchart

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   Start     â”‚
         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ stackIn = [],      â”‚
      â”‚ stackOut = []      â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ push(x):               â”‚
     â”‚   stackIn.push(x)      â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ pop():                 â”‚
     â”‚ if stackOut empty:     â”‚
     â”‚   move stackInâ†’stackOutâ”‚
     â”‚ return stackOut.pop()  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ peek():                â”‚
     â”‚ if stackOut empty:     â”‚
     â”‚   move stackInâ†’stackOutâ”‚
     â”‚ return stackOut.top()  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ empty():               â”‚
     â”‚ return both empty?     â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ‘¦ Explanation for a 10-year-old Indian kid

Think of a **queue** like a line at the ration shop â†’ the person who comes first gets served first.

But you only have **stacks** (like a pile of books, take from top).

Trick:

* When someone joins the line â†’ put them in `stackIn`.
* When you need to serve (pop) or see front â†’ if `stackOut` is empty, flip all books from `stackIn` into `stackOut`.
* Now the oldest person is on top of `stackOut`, ready to serve first.

---

### âœ¨ Easy Second Look (Beginnerâ€™s view)

* Use 2 stacks.
* `push`: add to stackIn.
* `pop`: if stackOut empty, move stackIn to stackOut, then pop.
* `peek`: same as pop but just see.
* `empty`: check both empty.

Thatâ€™s it â†’ Queue using Stacks solved easily!

---


