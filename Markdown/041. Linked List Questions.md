# LeetCode 25: Reverse Nodes in k-Group (Recursive Approach)

## Problem Scenario

Given a linked list, **reverse nodes in groups of size `k`**. If the number of nodes is not a multiple of `k`, leave the last nodes as they are.

**Example:**
Input: `1 → 2 → 3 → 4 → 5`, `k = 2`
Output: `2 → 1 → 4 → 3 → 5`

Input: `1 → 2 → 3 → 4 → 5`, `k = 3`
Output: `3 → 2 → 1 → 4 → 5`

---

## Algorithm

1. **Base case:** If `head` is null, `head.next` is null, or `k == 1`, return `head`.
2. Use `start` and `end` pointers at `head` to mark the current group.
3. Move `end` `k` steps forward.

   * If there are fewer than `k` nodes, return `head` (no reversal).
4. Reverse the nodes from `start` to `end` using a standard pointer reversal method.
5. Recursively call `reverseKGroup(end, k)` for the rest of the list and connect it to `start.next`.
6. Return the new head (`prev`) of the reversed group.

**Time Complexity:** O(n)
**Space Complexity:** O(n/k) due to recursion

---

## Pseudocode

```
function reverseKGroup(head, k):
    if head == null OR head.next == null OR k == 1:
        return head

    start = head
    end = head
    for i = 0 to k-1:
        if end == null:
            return head
        end = end.next

    prev = null
    current = start
    while current != end:
        temp = current.next
        current.next = prev
        prev = current
        current = temp

    start.next = reverseKGroup(end, k)
    return prev
```

---

## Flowchart

```
Start
  |
  v
Check base case: head==null OR head.next==null OR k==1 → Yes → return head
  |
  No
  v
Initialize start = head, end = head
  |
  v
Move end k steps forward
  |  
  v
If end == null → return head
  |
  v
Reverse nodes from start to end → prev
  |
  v
Connect start.next to reverseKGroup(end, k)
  |
  v
Return prev
```

---

## Well-Visualized Example

**Input:** `1 → 2 → 3 → 4 → 5`, `k = 2`

1. First group: `1 → 2` → reversed → `2 → 1`

   * Remaining list: `3 → 4 → 5`
2. Second group: `3 → 4` → reversed → `4 → 3`

   * Remaining node: `5` → left as is
3. Connect all groups: `2 → 1 → 4 → 3 → 5`

**Key Points:**

* Reversal is **exclusive of `end`**.
* Recursive call handles remaining groups efficiently.
* Works for **any k ≥ 1**, including cases where the last group is smaller than k.


# LeetCode 19: Remove Nth Node From End of List

## Problem Scenario

Given the head of a linked list and an integer `n`, **remove the nth node from the end** of the list and return the modified head.

**Example:**
Input: `1 → 2 → 3 → 4 → 5`, `n = 2`
Output: `1 → 2 → 3 → 5`

Input: `1 → 2`, `n = 2`
Output: `2`

---

## Algorithm (Using List Reversal)

1. Reverse the linked list.
2. Remove the nth node from the **start** (which is equivalent to the nth from the end in the original list).

   * If `n == 1`, remove the head → `reversed = reversed.next`.
   * Else, traverse to the `(n-1)th` node and skip the next node → `temp.next = temp.next.next`.
3. Reverse the list again to restore the original order with the node removed.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

## Pseudocode

```
function reverse(head):
    prev = null
    current = head
    while current != null:
        temp = current.next
        current.next = prev
        prev = current
        current = temp
    return prev

function removeNthFromEnd(head, n):
    reversed = reverse(head)
    
    if n == 1:
        reversed = reversed.next
    else:
        temp = reversed
        for i = 1 to n-2:
            temp = temp.next
        if temp.next != null:
            temp.next = temp.next.next

    return reverse(reversed)
```

---

## Flowchart

```
Start
  |
  v
Reverse the linked list → reversed
  |
  v
Check n:
    If n == 1 → remove head → reversed = reversed.next
    Else → traverse to (n-1)th node → skip next node
  |
  v
Reverse the list again
  |
  v
Return new head
```

---

## Well-Visualized Example

**Input:** `1 → 2 → 3 → 4 → 5`, `n = 2`

1. Reverse list → `5 → 4 → 3 → 2 → 1`
2. Remove 2nd node → `5 → 4 → 3 → 1`
3. Reverse again → `1 → 3 → 4 → 5`

**Key Points:**

* Reversing simplifies removal from the **end** without calculating list length.
* Works in **O(n) time** with **O(1) extra space**.
* Alternative methods: two-pointer technique (fast/slow) avoids double reversal.


# LeetCode 24: Swap Nodes in Pairs

## Problem Scenario

Given a linked list, **swap every two adjacent nodes** and return its head. You may **not modify the values** in the list, only nodes themselves.

**Example:**
Input: `1 → 2 → 3 → 4`
Output: `2 → 1 → 4 → 3`

Input: `1 → 2 → 3`
Output: `2 → 1 → 3`

---

## Algorithm (Recursive + k-Group Style)

1. **Base case:** If `head` is null or `head.next` is null, return `head`.
2. Use `start` and `end` pointers to mark the current pair (k = 2).
3. Move `end` **2 steps** forward.
4. Reverse the nodes from `start` to `end` using standard pointer reversal.
5. Recursively call `swapPairs(end)` for the remaining list and connect it to `start.next`.
6. Return `prev` as the new head of the reversed pair.

**Time Complexity:** O(n)
**Space Complexity:** O(n/2) due to recursion

---

## Pseudocode

```
function swapPairs(head):
    if head == null OR head.next == null:
        return head

    start = head
    end = head
    for i = 0 to 1:  // k = 2
        if end == null:
            return head
        end = end.next

    prev = null
    current = start
    while current != end:
        temp = current.next
        current.next = prev
        prev = current
        current = temp

    start.next = swapPairs(end)
    return prev
```

---

## Flowchart

```
Start
  |
  v
Check base case: head==null OR head.next==null → return head
  |
  v
Initialize start = head, end = head
  |
  v
Move end 2 steps forward
  |
  v
Reverse nodes from start to end → prev
  |
  v
Connect start.next to swapPairs(end)
  |
  v
Return prev
```

---

## Well-Visualized Example

**Input:** `1 → 2 → 3 → 4`

1. First pair: `1 → 2` → reversed → `2 → 1`

   * Remaining list: `3 → 4`
2. Second pair: `3 → 4` → reversed → `4 → 3`
3. Connect all pairs: `2 → 1 → 4 → 3`

**Key Points:**

* Works by **reversing each group of 2 nodes**, similar to k-group reversal.
* Recursion handles remaining pairs efficiently.
* Handles **odd number of nodes** automatically; the last node remains unchanged.
