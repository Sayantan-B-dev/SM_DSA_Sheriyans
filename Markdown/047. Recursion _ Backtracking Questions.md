# 1. Letter Combinations of a Phone Number (LeetCode 17)

---

## Problem Understanding

* Given a string of digits from `2` to `9`.
* Each digit maps to **letters on a phone keypad**.
* Generate **all possible letter combinations** the number could represent.

**Example:** `"23"` → `["ad","ae","af","bd","be","bf","cd","ce","cf"]`

---

## Approach

* Use **backtracking / recursion**:

  1. Maintain `cur` as the current combination being built.
  2. For each digit at index `i`, loop over its corresponding letters.
  3. Append a letter to `cur` and recurse for next index `i+1`.
  4. Base case: when `i == digits.length`, add `cur` to `ans`.
* If input is empty, return an empty array immediately.

---

## Algorithm

1. Map each digit `2-9` to its corresponding letters using a dictionary or map.
2. Initialize `ans = []`.
3. Recursive function `answer(i, cur)`:

   * **Base case:** If `i == digits.length` and `cur` is non-empty, push `cur` to `ans`.
   * Get letters for `digits[i]`.
   * For each letter, call `answer(i+1, cur + letter)`.
4. Call `answer(0, "")`.
5. Return `ans`.

---

## Pseudocode

```
FUNCTION letterCombinations(digits):
    IF digits is empty: RETURN []
    map = { "2":"abc", "3":"def", ..., "9":"wxyz" }
    ans = []
    FUNCTION answer(i, cur):
        IF i == length(digits):
            IF cur is not empty: ans.push(cur)
            RETURN
        letters = map[digits[i]]
        FOR letter in letters:
            answer(i+1, cur + letter)
    CALL answer(0, "")
    RETURN ans
```

---

## Dry Run Example (digits = "23")

```
i=0, cur=""
letters="abc"
Pick 'a' -> cur="a"
  i=1, letters="def"
    Pick 'd' -> cur="ad" -> add "ad"
    Pick 'e' -> cur="ae" -> add "ae"
    Pick 'f' -> cur="af" -> add "af"
Pick 'b' -> cur="b"
  i=1, letters="def"
    "bd","be","bf" added
Pick 'c' -> cur="c"
  i=1, letters="def"
    "cd","ce","cf" added
```

---

# 2. Combination Sum (LeetCode 39)

## Problem Understanding

* Given an array of **candidate numbers** (no duplicates) and a **target**.
* Find **all unique combinations** where the candidate numbers sum to the target.
* **Each number can be used unlimited times**.

**Example:**
`candidates = [2,3,6,7], target = 7` → `[[2,2,3],[7]]`

---

## Approach

* Use **backtracking / recursion**:

  1. Maintain `cur` as the current combination and `sum` as its sum.
  2. At index `i`, **two choices**:

     * **Pick candidates[i]** → add to `cur`, recurse with same `i` (because repeated use allowed), add to sum.
     * **Not pick candidates[i]** → recurse to `i+1`.
  3. **Base cases**:

     * If `sum == target` → add a copy of `cur` to `ans`.
     * If `sum > target` or `i == candidates.length` → return (stop).

---

## Algorithm

1. Initialize `ans = []`.
2. Recursive function `answer(i, cur, sum)`:

   * If `sum == target`, push copy of `cur` to `ans` and return.
   * If `i == candidates.length` or `sum > target`, return.
   * **Pick** `candidates[i]`:

     * `cur.push(candidates[i])`
     * Recurse with `i` and `sum + candidates[i]`
     * Backtrack `cur.pop()`
   * **Not pick** → recurse with `i+1` and same sum.
3. Call `answer(0, [], 0)`.
4. Return `ans`.

---

## Pseudocode

```
FUNCTION combinationSum(candidates, target):
    ans = []
    FUNCTION answer(i, cur, sum):
        IF sum == target:
            ans.push(copy(cur))
            RETURN
        IF i == length(candidates) OR sum > target:
            RETURN
        cur.push(candidates[i])
        answer(i, cur, sum + candidates[i])   // Pick
        cur.pop()
        answer(i+1, cur, sum)                 // Not Pick
    CALL answer(0, [], 0)
    RETURN ans
```

---

## Dry Run Example (candidates=[2,3], target=7)

```
i=0, cur=[], sum=0
Pick 2 -> cur=[2], sum=2
  Pick 2 -> cur=[2,2], sum=4
    Pick 2 -> cur=[2,2,2], sum=6
      Pick 2 -> cur=[2,2,2,2], sum=8 -> stop
      Not pick -> i=1, Pick 3 -> cur=[2,2,2,3], sum=9 -> stop
    Not pick -> i=1, Pick 3 -> cur=[2,2,3], sum=7 -> add [2,2,3]
  Not pick -> i=1, Pick 3 -> cur=[2,3], sum=5
    Pick 3 -> cur=[2,3,3], sum=8 -> stop
Not pick -> i=1, Pick 3 -> cur=[3], sum=3
  Pick 3 -> cur=[3,3], sum=6
    Pick 3 -> cur=[3,3,3], sum=9 -> stop
Result: [[2,2,3]]
```
