## **1. What is Binary Search?**

Binary search is a **divide-and-conquer algorithm** to find an element in a **sorted array** (ascending or descending).

**Idea:**

* Compare the target with the middle element.
* If target = middle → return index.
* If target < middle → search in left half.
* If target > middle → search in right half.
* Repeat until the range is empty.

**Time Complexity:**

* O(log n) → very efficient for large datasets.
  **Space Complexity:**
* O(1) for iterative
* O(log n) for recursive (due to recursion stack)

---

## **2. When to Use Binary Search**

* **Always sorted array** or data that can be **logically divided**.
* Finding an **element**.
* Finding **first/last occurrence** of an element.
* Searching in **monotonic functions** (e.g., “smallest X such that condition is true”).
* Optimizing problems with **search over answer** patterns (e.g., capacity, time, distance).

**Do NOT use binary search** on unsorted arrays unless you sort first.

---

## **3. Binary Search Algorithm (Pseudo Code)**

### **Iterative Version**

```
binarySearch(arr, target):
    low = 0
    high = length(arr) - 1
    
    while low <= high:
        mid = low + (high - low) // 2   // prevents overflow
        if arr[mid] == target:
            return mid
        else if arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1   // element not found
```

### **Recursive Version**

```
binarySearchRecursive(arr, target, low, high):
    if low > high:
        return -1
    mid = low + (high - low) // 2
    if arr[mid] == target:
        return mid
    else if arr[mid] < target:
        return binarySearchRecursive(arr, target, mid+1, high)
    else:
        return binarySearchRecursive(arr, target, low, mid-1)
```

---

## **4. Variants of Binary Search**

1. **First Occurrence of Element**

```
low = 0, high = n-1
ans = -1
while low <= high:
    mid = low + (high - low)//2
    if arr[mid] == target:
        ans = mid
        high = mid - 1   // go left to find first
    else if arr[mid] < target:
        low = mid + 1
    else:
        high = mid - 1
return ans
```

2. **Last Occurrence of Element**

```
low = 0, high = n-1
ans = -1
while low <= high:
    mid = low + (high - low)//2
    if arr[mid] == target:
        ans = mid
        low = mid + 1   // go right to find last
    else if arr[mid] < target:
        low = mid + 1
    else:
        high = mid - 1
return ans
```

3. **Lower Bound / Upper Bound** (First element ≥ target, first element > target)

4. **Search in Rotated Sorted Array** (LeetCode 33)

5. **Search in Infinite Array or Unknown Size**

6. **Binary Search on Answer** – e.g., “minimum maximum capacity” (LeetCode 410)

---

## **5. How to Use Binary Search in LeetCode Problems**

### **Classic Problems**

| Problem                                                                                                           | Idea / Usage                                                        |
| ----------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| [Binary Search](https://leetcode.com/problems/binary-search/)                                                     | Find element in sorted array                                        |
| [First Bad Version](https://leetcode.com/problems/first-bad-version/)                                             | Find first element satisfying a condition (binary search on answer) |
| [Search Insert Position](https://leetcode.com/problems/search-insert-position/)                                   | Lower bound concept                                                 |
| [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)       | Modified binary search in rotated array                             |
| [Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/) | Binary search on answer (monotonic function)                        |
| [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)                         | Binary search on partition index                                    |

---

## **6. Step-by-Step Example**

**Array:** `[1, 3, 5, 7, 9, 11]`, **target = 7**

* `low=0, high=5` → `mid=2` → `arr[2]=5` < 7 → search right
* `low=3, high=5` → `mid=4` → `arr[4]=9` > 7 → search left
* `low=3, high=3` → `mid=3` → `arr[3]=7` → FOUND → return 3

✅ Works in **O(log n)**

---

## **7. Tips & Tricks**

1. Always calculate `mid` as `low + (high - low)//2` → prevents overflow.
2. Binary search **requires sorted data**.
3. For first/last occurrence → adjust `low` and `high` after finding `mid`.
4. For **conditions**, use **binary search on answer pattern**.
5. If array is **rotated**, check which side is sorted to decide where to go.

---