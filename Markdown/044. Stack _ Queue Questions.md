# Largest Rectangle in Histogram (LeetCode 84)

---

### ğŸ“˜ Explanation

We are given an array `heights` representing heights of histogram bars.
We need to find the **largest rectangle area** that can be formed using consecutive bars.

Key idea: For each bar, find:

1. **Next smaller element to left**
2. **Next smaller element to right**

The width of the rectangle = `(right index - left index - 1)`
Area = `height * width`

We can solve this efficiently using **monotonic stacks**.

---

### ğŸ“ Algorithm (Step-by-step)

1. Initialize two arrays `left` and `right`.
2. Traverse from left to right to fill `left[i]` = index of **previous smaller bar**.
3. Traverse from right to left to fill `right[i]` = index of **next smaller bar**.
4. For each bar `i`, calculate area = `heights[i] * (right[i] - left[i] - 1)`.
5. Return the maximum area.

**Optimal version:**

* Use **one stack** and append a sentinel `0` at the end.
* While current bar < top of stack â†’ pop and calculate area immediately.

---

### ğŸ”‘ Pseudocode

```
function largestRectangleArea(heights):
    heights.push(0)  // sentinel
    stack = []
    maxArea = 0
    n = length of heights

    for i = 0 to n-1:
        while stack not empty AND heights[stack.top()] >= heights[i]:
            h = heights[stack.pop()]
            right = i
            left = stack.top() + 1 if stack not empty else 0
            area = h * (right - left)
            maxArea = max(maxArea, area)
        stack.push(i)
    
    return maxArea
```

---

### ğŸ§® Dry Run

Input: [2,1,5,6,2,3]

* Append 0 â†’ [2,1,5,6,2,3,0]
* stack=[]

i=0 â†’ push 0 â†’ stack=[0]
i=1 â†’ heights[0]=2 â‰¥ 1 â†’ pop 0 â†’ left=0, right=1, area=2*1=2 â†’ maxArea=2 â†’ push 1 â†’ stack=[1]
i=2 â†’ push 2 â†’ stack=[1,2]
i=3 â†’ push 3 â†’ stack=[1,2,3]
i=4 â†’ heights[3]=6â‰¥2 â†’ pop3 â†’ left=2, right=4, area=6*1=6 â†’ maxArea=6
heights[2]=5â‰¥2 â†’ pop2 â†’ left=1, right=4, area=5*2=10 â†’ maxArea=10 â†’ push4 â†’ stack=[1,4]
i=5 â†’ push5 â†’ stack=[1,4,5]
i=6 â†’ heights[5]=3â‰¥0 â†’ pop5 â†’ left=4, right=6, area=3*1=3 â†’ maxArea=10
heights[4]=2â‰¥0 â†’ pop4 â†’ left=1, right=6, area=2*4=8 â†’ maxArea=10
heights[1]=1â‰¥0 â†’ pop1 â†’ left=0, right=6, area=1*6=6 â†’ maxArea=10 â†’ push6 â†’ stack=[6]

âœ… Output = 10

---

### ğŸ–¼ï¸ Flowchart

```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Start       â”‚
          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Append 0 to heights â”‚
        â”‚ Initialize stack & maxArea=0 â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ For i = 0 to n-1  â”‚
       â”‚ While stack not empty AND â”‚
       â”‚ heights[stack.top()] â‰¥ heights[i] â”‚
       â”‚   pop, calculate area, update max â”‚
       â”‚ push i into stack â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
          â”‚ Return maxArea â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ‘¦ Explanation for a 10-year-old Indian kid

Imagine bars of buildings on a street. You want the **largest rectangle of buildings** that touches the ground.

Trick:

* For every building, check how far left and right you can extend **without hitting a smaller building**.
* Width = distance between smaller buildings on left and right.
* Area = width * height.
* Using a **stack**, you can quickly find next smaller building.

---

### âœ¨ Easy Second Look (Beginnerâ€™s view)

* Add sentinel `0` at end.
* Use one stack to store indices.
* If current bar smaller than top â†’ pop and calculate area.
* Keep updating maxArea.
* Done â†’ Largest rectangle found!

---

# Maximal Rectangle (LeetCode 85)

---

### ğŸ“˜ Explanation

We are given a **2D binary matrix** (0s and 1s).
We need to find the **largest rectangle containing only 1s**.

Key idea:

* Treat each row as the **base of a histogram**.
* For each row, compute **heights** of consecutive 1s in each column.
* Apply **Largest Rectangle in Histogram (LC84)** on each rowâ€™s histogram.

---

### ğŸ“ Algorithm (Step-by-step)

1. Initialize a `pSum` matrix of same size as input to store heights of consecutive 1s column-wise.
2. Traverse each column `j`:

   * For each row `i`:

     * If `matrix[i][j]` == '1' â†’ `pSum[i][j] = pSum[i-1][j] + 1` (or 1 if first row)
     * Else â†’ `pSum[i][j] = 0`
3. For each row in `pSum`, treat it as a histogram and calculate **largest rectangle area** using LC84 function.
4. Track the maximum area across all rows.

---

### ğŸ”‘ Pseudocode

```
function maximalRectangle(matrix):
    if matrix empty: return 0
    m = number of rows
    n = number of columns
    pSum = 2D array m x n initialized to 0
    
    // Build histogram heights
    for j = 0 to n-1:
        for i = 0 to m-1:
            if matrix[i][j] == '1':
                pSum[i][j] = pSum[i-1][j] + 1 if i>0 else 1
            else:
                pSum[i][j] = 0

    maxArea = 0
    for i = 0 to m-1:
        maxArea = max(maxArea, largestRectangleArea(pSum[i]))
    
    return maxArea
```

* `largestRectangleArea` â†’ same as LC84 solution using stack.

---

### ğŸ§® Dry Run

Matrix:

```
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
```

* Row 0 â†’ histogram heights = [1,0,1,0,0] â†’ LC84 â†’ maxArea=1
* Row 1 â†’ [2,0,2,1,1] â†’ LC84 â†’ maxArea=3
* Row 2 â†’ [3,1,3,2,2] â†’ LC84 â†’ maxArea=6
* Row 3 â†’ [4,0,0,3,0] â†’ LC84 â†’ maxArea remains 6

âœ… Output = 6

---

### ğŸ–¼ï¸ Flowchart

```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Start       â”‚
          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Initialize pSum[][]â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Build histogram:  â”‚
      â”‚ For each cell:    â”‚
      â”‚   if '1' â†’ height â”‚
      â”‚   else â†’ 0        â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ For each row:     â”‚
      â”‚   maxArea = max(  â”‚
      â”‚      maxArea,     â”‚
      â”‚      LC84(row) )  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Return maxArea â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ‘¦ Explanation for a 10-year-old Indian kid

Imagine a **grid of 1s and 0s**, like Lego blocks:

* 1 â†’ block exists
* 0 â†’ empty space

We want the **biggest rectangle made of only blocks (1s)**.

Trick:

1. For each row, calculate **height of blocks in each column** (how many consecutive 1s above).
2. Now each row is like a **histogram of building heights**.
3. Apply **Largest Rectangle in Histogram** to find biggest rectangle in that row.
4. Repeat for all rows â†’ maximum rectangle found.

---

### âœ¨ Easy Second Look (Beginnerâ€™s view)

* Convert each row into histogram heights column-wise.
* For each row, use LC84 (stack-based) to calculate max rectangle.
* Keep track of largest rectangle across all rows.

Thatâ€™s it â†’ Maximal Rectangle solved easily!

---
