# Largest Rectangle in Histogram (LeetCode 84)

---

### 📘 Explanation

We are given an array `heights` representing heights of histogram bars.
We need to find the **largest rectangle area** that can be formed using consecutive bars.

Key idea: For each bar, find:

1. **Next smaller element to left**
2. **Next smaller element to right**

The width of the rectangle = `(right index - left index - 1)`
Area = `height * width`

We can solve this efficiently using **monotonic stacks**.

---

### 📝 Algorithm (Step-by-step)

1. Initialize two arrays `left` and `right`.
2. Traverse from left to right to fill `left[i]` = index of **previous smaller bar**.
3. Traverse from right to left to fill `right[i]` = index of **next smaller bar**.
4. For each bar `i`, calculate area = `heights[i] * (right[i] - left[i] - 1)`.
5. Return the maximum area.

**Optimal version:**

* Use **one stack** and append a sentinel `0` at the end.
* While current bar < top of stack → pop and calculate area immediately.

---

### 🔑 Pseudocode

```
function largestRectangleArea(heights):
    heights.push(0)  // sentinel
    stack = []
    maxArea = 0
    n = length of heights

    for i = 0 to n-1:
        while stack not empty AND heights[stack.top()] >= heights[i]:
            h = heights[stack.pop()]
            right = i
            left = stack.top() + 1 if stack not empty else 0
            area = h * (right - left)
            maxArea = max(maxArea, area)
        stack.push(i)
    
    return maxArea
```

---

### 🧮 Dry Run

Input: [2,1,5,6,2,3]

* Append 0 → [2,1,5,6,2,3,0]
* stack=[]

i=0 → push 0 → stack=[0]
i=1 → heights[0]=2 ≥ 1 → pop 0 → left=0, right=1, area=2*1=2 → maxArea=2 → push 1 → stack=[1]
i=2 → push 2 → stack=[1,2]
i=3 → push 3 → stack=[1,2,3]
i=4 → heights[3]=6≥2 → pop3 → left=2, right=4, area=6*1=6 → maxArea=6
heights[2]=5≥2 → pop2 → left=1, right=4, area=5*2=10 → maxArea=10 → push4 → stack=[1,4]
i=5 → push5 → stack=[1,4,5]
i=6 → heights[5]=3≥0 → pop5 → left=4, right=6, area=3*1=3 → maxArea=10
heights[4]=2≥0 → pop4 → left=1, right=6, area=2*4=8 → maxArea=10
heights[1]=1≥0 → pop1 → left=0, right=6, area=1*6=6 → maxArea=10 → push6 → stack=[6]

✅ Output = 10

---

### 🖼️ Flowchart

```
          ┌────────────┐
          │ Start       │
          └─────┬──────┘
                │
        ┌───────▼─────────┐
        │ Append 0 to heights │
        │ Initialize stack & maxArea=0 │
        └────────┬─────────┘
                 │
       ┌─────────▼─────────┐
       │ For i = 0 to n-1  │
       │ While stack not empty AND │
       │ heights[stack.top()] ≥ heights[i] │
       │   pop, calculate area, update max │
       │ push i into stack │
       └─────────┬─────────┘
                 │
          ┌──────▼─────┐
          │ Return maxArea │
          └─────────────┘
```

---

### 👦 Explanation for a 10-year-old Indian kid

Imagine bars of buildings on a street. You want the **largest rectangle of buildings** that touches the ground.

Trick:

* For every building, check how far left and right you can extend **without hitting a smaller building**.
* Width = distance between smaller buildings on left and right.
* Area = width * height.
* Using a **stack**, you can quickly find next smaller building.

---

### ✨ Easy Second Look (Beginner’s view)

* Add sentinel `0` at end.
* Use one stack to store indices.
* If current bar smaller than top → pop and calculate area.
* Keep updating maxArea.
* Done → Largest rectangle found!

---

# Maximal Rectangle (LeetCode 85)

---

### 📘 Explanation

We are given a **2D binary matrix** (0s and 1s).
We need to find the **largest rectangle containing only 1s**.

Key idea:

* Treat each row as the **base of a histogram**.
* For each row, compute **heights** of consecutive 1s in each column.
* Apply **Largest Rectangle in Histogram (LC84)** on each row’s histogram.

---

### 📝 Algorithm (Step-by-step)

1. Initialize a `pSum` matrix of same size as input to store heights of consecutive 1s column-wise.
2. Traverse each column `j`:

   * For each row `i`:

     * If `matrix[i][j]` == '1' → `pSum[i][j] = pSum[i-1][j] + 1` (or 1 if first row)
     * Else → `pSum[i][j] = 0`
3. For each row in `pSum`, treat it as a histogram and calculate **largest rectangle area** using LC84 function.
4. Track the maximum area across all rows.

---

### 🔑 Pseudocode

```
function maximalRectangle(matrix):
    if matrix empty: return 0
    m = number of rows
    n = number of columns
    pSum = 2D array m x n initialized to 0
    
    // Build histogram heights
    for j = 0 to n-1:
        for i = 0 to m-1:
            if matrix[i][j] == '1':
                pSum[i][j] = pSum[i-1][j] + 1 if i>0 else 1
            else:
                pSum[i][j] = 0

    maxArea = 0
    for i = 0 to m-1:
        maxArea = max(maxArea, largestRectangleArea(pSum[i]))
    
    return maxArea
```

* `largestRectangleArea` → same as LC84 solution using stack.

---

### 🧮 Dry Run

Matrix:

```
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
```

* Row 0 → histogram heights = [1,0,1,0,0] → LC84 → maxArea=1
* Row 1 → [2,0,2,1,1] → LC84 → maxArea=3
* Row 2 → [3,1,3,2,2] → LC84 → maxArea=6
* Row 3 → [4,0,0,3,0] → LC84 → maxArea remains 6

✅ Output = 6

---

### 🖼️ Flowchart

```
          ┌─────────────┐
          │ Start       │
          └─────┬───────┘
                │
      ┌─────────▼─────────┐
      │ Initialize pSum[][]│
      └─────────┬─────────┘
                │
      ┌─────────▼─────────┐
      │ Build histogram:  │
      │ For each cell:    │
      │   if '1' → height │
      │   else → 0        │
      └─────────┬─────────┘
                │
      ┌─────────▼─────────┐
      │ For each row:     │
      │   maxArea = max(  │
      │      maxArea,     │
      │      LC84(row) )  │
      └─────────┬─────────┘
                │
        ┌───────▼───────┐
        │ Return maxArea │
        └───────────────┘
```

---

### 👦 Explanation for a 10-year-old Indian kid

Imagine a **grid of 1s and 0s**, like Lego blocks:

* 1 → block exists
* 0 → empty space

We want the **biggest rectangle made of only blocks (1s)**.

Trick:

1. For each row, calculate **height of blocks in each column** (how many consecutive 1s above).
2. Now each row is like a **histogram of building heights**.
3. Apply **Largest Rectangle in Histogram** to find biggest rectangle in that row.
4. Repeat for all rows → maximum rectangle found.

---

### ✨ Easy Second Look (Beginner’s view)

* Convert each row into histogram heights column-wise.
* For each row, use LC84 (stack-based) to calculate max rectangle.
* Keep track of largest rectangle across all rows.

That’s it → Maximal Rectangle solved easily!

---
